/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package simulator;

//import com.sun.org.apache.bcel.internal.classfile.LineNumber;
import java.awt.TextArea;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import javax.swing.JFrame;
/**
 *
 * @author Praveen M
 */
public class gui extends javax.swing.JFrame {

    public gui() {
        initComponents();
    }

    
    public static int[] memory=new int[2048];
    //Machine Status Register: certain bits record the status of the health of the machine
    public static int msr;
    public static int[] r=new int[4];
    public static String[] fr=new String[2];
    public static int[] ixarray=new int[3];
    public static int pc=0;
    public static int[] cc=new int[4]; 
    public static int immediate;
    public static int ea,rr,length,address1,address2;
    float exp, number, number2;
    int frr;
    int k=1021;
    
/*
memory[0]                       Reserved for the Trap instruction for Part III.
memory[1] 			Reserved for a machine fault (see below).
memory[2] 			Store PC for Trap
memory[4] 			Store PC for Machine Fault
*/

    cache cache1=new cache();
//    CacheLine cll=new CacheLine(ea, r, HEIGHT, WIDTH);
     
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jLabel21 = new javax.swing.JLabel();
        X1Textfield = new javax.swing.JTextField();
        jLabel22 = new javax.swing.JLabel();
        X2Textfield = new javax.swing.JTextField();
        IXTextfield = new javax.swing.JTextField();
        X3Textfield = new javax.swing.JTextField();
        jLabel25 = new javax.swing.JLabel();
        jLabel20 = new javax.swing.JLabel();
        CCTextfield = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        PCTextfield = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        R0Textfield = new javax.swing.JTextField();
        R1TextField = new javax.swing.JTextField();
        R2Textfield = new javax.swing.JTextField();
        R3Textfield = new javax.swing.JTextField();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jLabel11 = new javax.swing.JLabel();
        jLabel23 = new javax.swing.JLabel();
        X1Textfield1 = new javax.swing.JTextField();
        jLabel24 = new javax.swing.JLabel();
        X2Textfield1 = new javax.swing.JTextField();
        IXTextfield1 = new javax.swing.JTextField();
        X3Textfield1 = new javax.swing.JTextField();
        jLabel17 = new javax.swing.JLabel();
        OPCODETextfield = new javax.swing.JTextField();
        jLabel15 = new javax.swing.JLabel();
        AddressTextfield = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        TextArea = new javax.swing.JTextArea();
        jLabel19 = new javax.swing.JLabel();
        jLabel18 = new javax.swing.JLabel();
        jLabel16 = new javax.swing.JLabel();
        jLabel26 = new javax.swing.JLabel();
        jLabel27 = new javax.swing.JLabel();
        IRTextField = new javax.swing.JTextField();
        MARTextField = new javax.swing.JTextField();
        MBRTextField = new javax.swing.JTextField();
        MFRTextField = new javax.swing.JTextField();
        MSRTextField = new javax.swing.JTextField();
        jLabel28 = new javax.swing.JLabel();
        ITextField = new javax.swing.JTextField();
        StartButton1 = new javax.swing.JButton();
        HaltButton1 = new javax.swing.JButton();
        ClearButton = new javax.swing.JButton();
        IPLButton = new javax.swing.JButton();
        jLabel29 = new javax.swing.JLabel();
        R0RadioButton = new javax.swing.JRadioButton();
        R1RadioButton = new javax.swing.JRadioButton();
        R2RadioButton = new javax.swing.JRadioButton();
        R3RadioButton = new javax.swing.JRadioButton();
        jLabel12 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        AddressTextField1 = new javax.swing.JTextField();
        DataTextField = new javax.swing.JTextField();
        jLabel14 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        SingleStepButton = new javax.swing.JButton();
        Program1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        TextArea2 = new javax.swing.JTextArea();
        Program2 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        instructiontext = new javax.swing.JTextField();
        jLabel30 = new javax.swing.JLabel();
        jLabel31 = new javax.swing.JLabel();
        jLabel32 = new javax.swing.JLabel();
        jButton4 = new javax.swing.JButton();
        jLabel33 = new javax.swing.JLabel();
        jLabel34 = new javax.swing.JLabel();
        jLabel35 = new javax.swing.JLabel();
        F0TextField = new javax.swing.JTextField();
        F1TextField = new javax.swing.JTextField();

        jLabel5.setText("X1");

        jLabel6.setText("X2");

        jLabel7.setText("X3");

        jLabel21.setText("INDEX REGISTERS");

        jLabel22.setText("IX");

        IXTextfield.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                IXTextfieldActionPerformed(evt);
            }
        });

        jLabel25.setText("REGISTER");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setBackground(new java.awt.Color(255, 255, 255));
        setForeground(java.awt.Color.white);

        jLabel20.setText("CC");

        CCTextfield.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CCTextfieldActionPerformed(evt);
            }
        });

        jLabel8.setText("PC");

        PCTextfield.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PCTextfieldActionPerformed(evt);
            }
        });

        jLabel1.setText("R0");

        jLabel2.setText("R1");

        jLabel3.setText("R2");

        jLabel4.setText("R3");

        R0Textfield.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                R0TextfieldActionPerformed(evt);
            }
        });

        jLabel9.setText("X1");

        jLabel10.setText("X2");

        jLabel11.setText("X3");

        jLabel23.setText("INDEX REGISTERS");

        jLabel24.setText("IX");

        IXTextfield1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                IXTextfield1ActionPerformed(evt);
            }
        });

        jLabel17.setText("OPCODE:");

        OPCODETextfield.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                OPCODETextfieldActionPerformed(evt);
            }
        });

        jLabel15.setText("MEMORY ADDRESS");

        AddressTextfield.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AddressTextfieldActionPerformed(evt);
            }
        });

        TextArea.setColumns(20);
        TextArea.setRows(5);
        jScrollPane1.setViewportView(TextArea);

        jLabel19.setText("MSR");

        jLabel18.setText("MFR");

        jLabel16.setText("MBR");

        jLabel26.setText("MAR");

        jLabel27.setText("IR");

        jLabel28.setText("INDIRECT ADDRESSING");

        StartButton1.setText("START");
        StartButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                StartButton1ActionPerformed(evt);
            }
        });

        HaltButton1.setText("HALT");
        HaltButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                HaltButton1ActionPerformed(evt);
            }
        });

        ClearButton.setText("CLEAR");
        ClearButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ClearButtonActionPerformed(evt);
            }
        });

        IPLButton.setText("IPL");
        IPLButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                IPLButtonActionPerformed(evt);
            }
        });

        jLabel29.setText("REGISTER");

        R0RadioButton.setText("R0");
        R0RadioButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                R0RadioButtonActionPerformed(evt);
            }
        });

        R1RadioButton.setText("R1");

        R2RadioButton.setText("R2");

        R3RadioButton.setText("R3");

        jLabel12.setText("DATA");

        jLabel13.setText("ADDRESS");

        jLabel14.setText("ADDING DATA TO MEMORY");

        jButton1.setText("STORE");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        SingleStepButton.setText("SINGLE STEP");
        SingleStepButton.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                SingleStepButtonMouseClicked(evt);
            }
        });
        SingleStepButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SingleStepButtonActionPerformed(evt);
            }
        });

        Program1.setText("Run Program 1");
        Program1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Program1ActionPerformed(evt);
            }
        });

        jButton2.setText("Click for \"How to run program 1\"");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        TextArea2.setColumns(20);
        TextArea2.setRows(5);
        jScrollPane2.setViewportView(TextArea2);

        Program2.setText("Run Program 2");
        Program2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Program2ActionPerformed(evt);
            }
        });

        jButton3.setText("See the sentences in the paragraph");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jLabel30.setText("INSTRUCTION");

        jLabel31.setText("PRINTER");

        jLabel32.setText("KEYBOARD");

        jButton4.setText("Click for \"How to run program 2\"");
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        jLabel33.setText("FLOATING REGISTER");

        jLabel34.setText("F0");

        jLabel35.setText("F1");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jLabel3)
                                            .addGap(18, 18, 18)
                                            .addComponent(R2Textfield))
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jLabel1)
                                            .addGap(18, 18, 18)
                                            .addComponent(R0Textfield, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(jLabel4)
                                            .addComponent(jLabel8)
                                            .addComponent(jLabel20, javax.swing.GroupLayout.Alignment.TRAILING))
                                        .addGap(18, 18, 18)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(PCTextfield, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(R3Textfield, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(CCTextfield, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE))))
                                .addGap(1, 1, 1))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addGap(18, 18, 18)
                                .addComponent(R1TextField, javax.swing.GroupLayout.PREFERRED_SIZE, 108, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel23)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(OPCODETextfield, javax.swing.GroupLayout.PREFERRED_SIZE, 88, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                    .addGap(4, 4, 4)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jLabel24)
                                            .addGap(12, 12, 12))
                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                                .addComponent(jLabel10)
                                                .addComponent(jLabel9)
                                                .addComponent(jLabel11))
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)))
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                        .addComponent(X1Textfield1)
                                        .addComponent(IXTextfield1)
                                        .addComponent(X2Textfield1, javax.swing.GroupLayout.PREFERRED_SIZE, 116, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(X3Textfield1, javax.swing.GroupLayout.PREFERRED_SIZE, 116, javax.swing.GroupLayout.PREFERRED_SIZE))))
                            .addComponent(jLabel17)
                            .addComponent(jLabel29)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(R0RadioButton)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(R1RadioButton)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(R2RadioButton)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(R3RadioButton))
                            .addComponent(jLabel15)
                            .addComponent(AddressTextfield, javax.swing.GroupLayout.PREFERRED_SIZE, 130, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(instructiontext, javax.swing.GroupLayout.PREFERRED_SIZE, 172, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel30)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                    .addComponent(jLabel35)
                                    .addGap(18, 18, 18)
                                    .addComponent(F1TextField))
                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                    .addComponent(jLabel34)
                                    .addGap(18, 18, 18)
                                    .addComponent(F0TextField))
                                .addComponent(jLabel33, javax.swing.GroupLayout.Alignment.LEADING)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 11, Short.MAX_VALUE)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 394, Short.MAX_VALUE)
                        .addComponent(jScrollPane2))
                    .addComponent(jLabel31)
                    .addComponent(jLabel32))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(jLabel28)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(ITextField, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(8, 8, 8))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(SingleStepButton, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(ClearButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(HaltButton1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(IPLButton, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel18)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(MFRTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel16)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(MBRTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                            .addComponent(jLabel27)
                                            .addComponent(jLabel26))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(IRTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(MARTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                            .addGap(19, 19, 19)
                                            .addComponent(jButton1))
                                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                .addGroup(layout.createSequentialGroup()
                                                    .addGap(19, 19, 19)
                                                    .addComponent(jLabel12))
                                                .addComponent(jLabel13, javax.swing.GroupLayout.Alignment.TRAILING))
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                .addComponent(AddressTextField1)
                                                .addComponent(DataTextField)))
                                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                            .addComponent(jLabel19)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                            .addComponent(MSRTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE))))
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addComponent(StartButton1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap())
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jButton3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 275, Short.MAX_VALUE)
                            .addComponent(Program2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(Program1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jButton2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                .addComponent(jLabel14, javax.swing.GroupLayout.PREFERRED_SIZE, 175, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(0, 0, Short.MAX_VALUE)))
                        .addGap(7, 7, 7))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jButton4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addContainerGap())))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel30)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(instructiontext, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addComponent(R0Textfield, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jLabel1))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(R1TextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel2))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(R2Textfield, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel3))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(R3Textfield, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel4))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(PCTextfield, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel8))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(CCTextfield, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel20))
                        .addGap(3, 3, 3))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel32)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 258, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel27)
                            .addComponent(IRTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel26)
                            .addComponent(MARTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel16)
                            .addComponent(MBRTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel18)
                            .addComponent(MFRTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(12, 12, 12)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(MSRTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel19))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButton2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Program1)
                        .addGap(22, 22, 22)
                        .addComponent(jButton4)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 21, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel31)
                            .addComponent(Program2))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 393, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jButton3)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                        .addComponent(jLabel14)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                            .addComponent(AddressTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jLabel13))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                            .addComponent(DataTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jLabel12))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jButton1)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                            .addComponent(jLabel28)
                                            .addComponent(ITextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(StartButton1)
                                        .addGap(146, 146, 146))
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                        .addComponent(HaltButton1)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(ClearButton)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(IPLButton)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(SingleStepButton)))))
                        .addContainerGap())
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addComponent(jLabel23)
                        .addGap(3, 3, 3)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel24)
                            .addComponent(IXTextfield1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(X1Textfield1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel9))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel10, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(X2Textfield1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel11)
                            .addComponent(X3Textfield1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel17, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(OPCODETextfield, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addComponent(jLabel29)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(R0RadioButton)
                            .addComponent(R1RadioButton)
                            .addComponent(R2RadioButton)
                            .addComponent(R3RadioButton))
                        .addGap(18, 18, 18)
                        .addComponent(jLabel15)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(AddressTextfield, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabel33)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel34)
                            .addComponent(F0TextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel35)
                            .addComponent(F1TextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void R0TextfieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_R0TextfieldActionPerformed
        // TODO ,dds,fndsfadd your handling code here:
    }//GEN-LAST:event_R0TextfieldActionPerformed

    private void IXTextfieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_IXTextfieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_IXTextfieldActionPerformed

    private void IXTextfield1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_IXTextfield1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_IXTextfield1ActionPerformed

    private void OPCODETextfieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_OPCODETextfieldActionPerformed

    }//GEN-LAST:event_OPCODETextfieldActionPerformed

    private void AddressTextfieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AddressTextfieldActionPerformed
    }//GEN-LAST:event_AddressTextfieldActionPerformed

    private void IPLButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_IPLButtonActionPerformed
       String instruction = new String("0000010100010000"); 
       TextArea2.append("\n"+instruction);
       ipl(instruction);
       instruction = "0000011001010001"; 
       TextArea2.append("\n"+instruction); 
       ipl(instruction);
       instruction = "0000010000101000"; 
       TextArea2.append("\n"+instruction); 
       ipl(instruction);
       instruction = "0000011010101001"; 
       TextArea2.append("\n"+instruction); 
       ipl(instruction);
       instruction = "0000111101000111"; 
       TextArea2.append("\n"+instruction); 
       ipl(instruction);
       instruction = "1010010001010001"; 
       TextArea2.append("\n"+instruction); 
       ipl(instruction);
       
    }//GEN-LAST:event_IPLButtonActionPerformed

    private void StartButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_StartButton1ActionPerformed
           
        
        
        fr[0]="0000001001000000";
        fr[1]="0000001001000000";
           String instruction=new String(instructiontext.getText());               //Storing the user input instruction 
           if(instruction.length()>16)
           {
               TextArea2.append("\nInvalid instruction, more than 16 bits");
            }
           int opcode=Integer.valueOf(instruction.substring(0,6));          //Finding substring(dividing the instruciton), opcode 
           int reg=Integer.valueOf(instruction.substring(6,8));             //string from 6 to 7 denotes register, converting it to integer
           int ix=Integer.valueOf(instruction.substring(8,10));             //string from 8 to 9 denotes IX
           int ival=Integer.valueOf(instruction.substring(10,11));                //Character at position 10 denotes I value
           String binaryaddress =instruction.substring(11,16);              
           int rr=Integer.parseInt(instruction.substring(6,8),2);
           int decaddress=Integer.parseInt(binaryaddress,2);
           int ixdec=Integer.parseInt(instruction.substring(8, 10),2);
           
           OPCODETextfield.setText(instruction.substring(0,6));             //Setting Opcode textfield to opcode found in input
           IXTextfield.setText(instruction.substring(8,10));                //Setting IX textfield to IX from input instruction    
           ITextField.setText(""+instruction.charAt(10));                   //setting I to I value from input instruction
           AddressTextfield.setText(instruction.substring(11,16));          //Setting address text field to address from input instruction
           
           if(reg==00)                                                      //Selecting the radio button of the register used in the instruction
               R0RadioButton.setSelected(true);
           if(reg==01)
               R0RadioButton.setSelected(true);
           if(reg==10)
               R0RadioButton.setSelected(true);
           if(reg==11)
               R0RadioButton.setSelected(true);
           
           int opdec=Integer.parseInt(instruction.substring(0,6),2);
        
           ea=effectiveaddress(ival,ixdec,decaddress);       //calling effective address funtion to calculate and return EA   
           if(opdec==61 || opdec==62 || opdec==63)
           {if(ea <= 5 && ea >= 0){
               msr = 0;
                   TextArea2.append("\nIllegal Memory Address to Reserved Locations, machine fault: 0 ");
                   MFRTextField.setText("0");

           }}
           
           IRTextField.setText(instruction);
           MARTextField.setText(""+ea);
           MBRTextField.setText(""+memory[ea]);
           
           
           if(opdec==1)
               loadregister(reg,ea,ival);                                   //LDR instruction function call
           if(opdec==2)
               storeregister(reg,ea,ival);                                       //STR instruciton function call
           if(opdec==3)
               loadregadd(reg,ea);                                          //LDA instruction function call
           if(opdec==41)
               loadindexreg(ix,ea,ival);                                         //LDX instruction funciton call
           if(opdec==42)    
               storeindexreg(ix,ea,ival);                                        //STX instruction function call
           if(opdec==0)
               TextArea2.append("\nHALT - Machine is stopped");
           if(opdec==10)                                                    //Jump if zero instruction
               jumpifzero(reg,pc,ea);
           if(opdec==11)                                                    //Jump if not equal
               jumpifnotequal(reg,pc,ea);
           if(opdec==12)                                                    //Jump if condition code
               jumpifcondcode(cc,pc,ea);
           if(opdec==13)                                                    //Unconditional jump to address
               uncondjump(pc,ea);
           if(opdec==14)                                                    //Jump and save return address
               jumpsavereturnadd(pc,ea);
           if(opdec==15)                                                    //Return from sub routine
           {
               immediate=decaddress;
               returnsubroutine(immediate);
           }
           if(opdec==16)                                                     //subtract one and branch   
               subtractbranch(reg,pc,ea);
           if(opdec==17)                                                     //Jump greater than or equal to   
               jumpgreater(reg,pc,ea);
           if(opdec==4)
               addmemtoreg(reg,ea,ival);
           if(opdec==5)
               submemfromreg(reg,ea,ival);
           if(opdec==6)
           {
               immediate=decaddress;
               addimmtoreg(reg,immediate);
           }
           if(opdec==7)
           {
               immediate=decaddress;
               subimmtoreg(reg,immediate);
           }
           if(opdec==20)        //Multipling two registers
           {
             int rx=Integer.parseInt(instruction.substring(6, 8),2);
             int ry=Integer.parseInt(instruction.substring(8,10),2);
             int x=r[rx];
             int y=r[ry];
             TextArea2.append("\nMultiplying registers R"+rx+" and R"+ry);
             multiplyregister(x,y,rx);
           }
           if(opdec==21)        //dividing two registers
           {
             int rx=Integer.parseInt(instruction.substring(6, 8),2);
             int ry=Integer.parseInt(instruction.substring(8,10),2);
             int x=r[rx];
             int y=r[ry];
             TextArea2.append("\nDividing registers R"+rx+" by R"+ry);
             divideregister(x,y,rx);
           }
           if(opdec==22) //test the equality of two registers
           {
             int rx=Integer.parseInt(instruction.substring(6, 8),2);
             int ry=Integer.parseInt(instruction.substring(8,10),2);
             int x=r[rx];
             int y=r[ry];
             TextArea2.append("\nTesting equality between registerss R"+rx+" and R"+ry);
             if(x==y)
             {
                 cc[4]=1;
                 CCTextfield.setText("EQUAL");
                 TextArea2.append("\nBoth registers are equal");
             }
             else
             {
                 cc[4]=0;
                CCTextfield.setText("NOT EQUAL");
                 TextArea2.append("\nBoth registers are not equal");
             }
           }
           if(opdec==23)// AND operation
           {
             int rx=Integer.parseInt(instruction.substring(6, 8),2);
             int ry=Integer.parseInt(instruction.substring(8,10),2);
             TextArea2.append("\nAND operation between registers R"+rx+" and R"+ry);
             TextArea2.append("\nResult is stored in R"+rx);
             int x=r[rx];
             int y=r[ry];
             r[rx] = x & y;
             if(rx==0)
                 R0Textfield.setText(Integer.toString(r[rx]));
             if(rx==1)
                 R1TextField.setText(Integer.toString(r[rx]));
             if(rx==2)
                 R2Textfield.setText(Integer.toString(r[rx]));
             if(rx==3)
                 R3Textfield.setText(Integer.toString(r[rx]));
           }
           if(opdec==24)// OR operation
           {
             int rx=Integer.parseInt(instruction.substring(6, 8),2);
             int ry=Integer.parseInt(instruction.substring(8,10),2);
             TextArea2.append("\nOR operation between registers R"+rx+" and R"+ry);
             TextArea2.append("\nResult is stored in R"+rx);
             int x=r[rx];
             int y=r[ry];
             r[rx] = x | y;
             if(rx==0)
                 R0Textfield.setText(Integer.toString(r[rx]));
             if(rx==1)
                 R1TextField.setText(Integer.toString(r[rx]));
             if(rx==2)
                 R2Textfield.setText(Integer.toString(r[rx]));
             if(rx==3)
                 R3Textfield.setText(Integer.toString(r[rx]));
           }
           if(opdec==25)//NOT operation
           {
             int rx=Integer.parseInt(instruction.substring(6, 8),2);
             TextArea2.append("\nNOT operation of register R"+rx);
             TextArea2.append("\nResult is stored in R"+rx);
             int x=r[rx];
             r[rx] = ~x;
             if(rx==0)
                 R0Textfield.setText(Integer.toString(r[rx]));
             if(rx==1)
                 R1TextField.setText(Integer.toString(r[rx]));
             if(rx==2)
                 R2Textfield.setText(Integer.toString(r[rx]));
             if(rx==3)
                 R3Textfield.setText(Integer.toString(r[rx]));
           }           
           if(opdec==31) //Shift register by count
           {
               int A_L=Integer.valueOf(instruction.substring(8,9));
               int L_R=Integer.valueOf(instruction.substring(8,9));
               int count=Integer.valueOf(instruction.substring(12,16));
               if(count==0)
               {
                 TextArea2.append("\nNo shift operation");
               }
               else
               {
                   if(reg==00)
                        TextArea2.append("\nShifing register R0 by "+count);
                   if(reg==01)
                        TextArea2.append("\nShifing register R1 by "+count);
                   if(reg==10)
                        TextArea2.append("\nShifing register R2 by "+count);
                   if(reg==11)
                        TextArea2.append("\nShifing register R3 by "+count);
                   shiftregister(A_L,L_R,count,reg);
               }
           }  
            if(opdec==32) //rotate register by count
           {
               int A_L=Integer.valueOf(instruction.substring(8,9));
               int L_R=Integer.valueOf(instruction.substring(8,9));
               int count=Integer.valueOf(instruction.substring(12,16));
               if(count==0)
               {
                   //No shifting
               }
               else
               {
                   if(reg==00)
                        TextArea2.append("\nRotating register R0 by "+count);
                   if(reg==01)
                        TextArea2.append("\nRotating register R1 by "+count);
                   if(reg==10)
                        TextArea2.append("\nRotating register R2 by "+count);
                   if(reg==11)
                        TextArea2.append("\nRotating register R3 by "+count);
                   rotateregister(A_L,L_R,count,reg);
               }   
           }
            
            if(opdec==30){   //Trap
               int trapCode=Integer.parseInt(instruction.substring(11,16),2); 
               if (trapCode > 16 || trapCode <0 ){
                   msr = 1;
                   TextArea2.append("\nIllegal TRAP code, machine fault: 1 ");
                   MFRTextField.setText("1");
               }else{
                   
               trapInstr(trapCode);
               }
           }
            
            if(opdec==61)   //IN instruction
            {
                TextArea2.append("\nExecuting IN instruction");
                int devid=Integer.parseInt(instruction.substring(11,16),2);
                String character=TextArea.getText();
                if(character.length()!=1)
                {
                  TextArea2.append("\nThe entered input in keyboard is not a character");
                }
                else
                {char c=character.charAt(0);
                if(devid==0)
                {if(reg==0)
                {
                    TextArea2.append("\nInput character to register 0 from keyboard");
                    r[0]=(int)c;
                }
                if(reg==1)
                {
                    TextArea2.append("\nInput character to register 1 from keyboard");
                    r[1]=(int)c;
                }
                if(reg==2)
                {
                    TextArea2.append("\nInput character to register 2 from keyboard");
                    r[2]=(int)c;                    
                }
                if(reg==3)
                {
                    TextArea2.append("\nInput character to register 3 from keyboard");
                    r[3]=(int)c;                    
                }
                }
                if(devid==4)
                {
                    TextArea2.append("\nInput character to register from MAR");
                    r[reg]=Integer.valueOf(IRTextField.getText());
                }
                if(devid==5)
                {
                    TextArea2.append("\nInput character to register from MAR");
                    r[reg]=Integer.valueOf(MARTextField.getText());
                }
                if(devid==6)
                {
                    TextArea2.append("\nInput character to register from MAR");
                    r[reg]=Integer.valueOf(MBRTextField.getText());
                }
                if(devid==7)
                {
                    TextArea2.append("\nInput character to register from MAR");
                    r[reg]=Integer.valueOf(MFRTextField.getText());
                }
                if(devid==8)
                {
                    TextArea2.append("\nInput character to register from MAR");
                    r[reg]=Integer.valueOf(MSRTextField.getText());
                }                
                if(devid==9)
                {
                    if(jButton2.getModel().isPressed())
                    {
                        TextArea2.append("\nButton is pressed");
                        r[rr]=1;
                    }
                    else
                    {
                        TextArea2.append("\nButton is not pressed");
                        r[rr]=0;
                    }
                }
                if(devid==10)
                {
                    if(Program1.getModel().isPressed())
                    {
                        TextArea2.append("\nButton is pressed");
                        r[rr]=1;
                    }
                    else
                    {
                        TextArea2.append("\nButton is not pressed");
                        r[rr]=0;
                    }
                }
                if(devid==11)
                {
                    if(jButton4.getModel().isPressed())
                    {
                        TextArea2.append("\nButton is pressed");
                        r[rr]=1;
                    }
                    else
                    {
                        TextArea2.append("\nButton is not pressed");
                        r[rr]=0;
                    }
                }
                if(devid==12)
                {
                    if(Program2.getModel().isPressed())
                    {
                        TextArea2.append("\nButton is pressed");
                        r[rr]=1;
                    }
                    else
                    {
                        TextArea2.append("\nButton is not pressed");
                        r[rr]=0;
                    }
                }
                if(devid==13)
                {
                    if(jButton3.getModel().isPressed())
                    {
                        TextArea2.append("\nButton is pressed");
                        r[rr]=1;
                    }
                    else
                    {
                        TextArea2.append("\nButton is not pressed");
                        r[rr]=0;
                    }
                }
                if(devid==14)
                {
                    if(jButton1.getModel().isPressed())
                    {
                        TextArea2.append("\nButton is pressed");
                        r[rr]=1;
                    }
                    else
                    {
                        TextArea2.append("\nButton is not pressed");
                        r[rr]=0;
                    }
                }                
                if(devid==15)
                {
                    if(StartButton1.getModel().isPressed())
                    {
                        TextArea2.append("\nButton is pressed");
                        r[rr]=1;
                    }
                    else
                    {
                        TextArea2.append("\nButton is not pressed");
                        r[rr]=0;
                    }
                }   
                if(devid==16)
                {
                    if(HaltButton1.getModel().isPressed())
                    {
                        TextArea2.append("\nButton is pressed");
                        r[rr]=1;
                    }
                    else
                    {
                        TextArea2.append("\nButton is not pressed");
                        r[rr]=0;
                    }
                }   
                if(devid==17)
                {
                    if(ClearButton.getModel().isPressed())
                    {
                        TextArea2.append("\nButton is pressed");
                        r[rr]=1;
                    }
                    else
                    {
                        TextArea2.append("\nButton is not pressed");
                        r[rr]=0;
                    }
                }   
                if(devid==18)
                {
                    if(IPLButton.getModel().isPressed())
                    {
                        TextArea2.append("\nButton is pressed");
                        r[rr]=1;
                    }
                    else
                    {
                        TextArea2.append("\nButton is not pressed");
                        r[rr]=0;
                    }
                }   
                if(devid==19)
                {
                    if(SingleStepButton.getModel().isPressed())
                    {
                        TextArea2.append("\nButton is pressed");
                        r[rr]=1;
                    }
                    else
                    {
                        TextArea2.append("\nButton is not pressed");
                        r[rr]=0;
                    }
                }                   
                if(devid==20)
                {
                    TextArea2.append("\nInput character to register from R0");
                    r[rr]=Integer.valueOf(R0Textfield.getText());
                }                
                 if(devid==21)
                {
                    TextArea2.append("\nInput character to register from R1");
                    r[rr]=Integer.valueOf(R1TextField.getText());
                }                               
                 if(devid==22)
                {
                    TextArea2.append("\nInput character to register from R2");
                    r[rr]=Integer.valueOf(R2Textfield.getText());
                }                               
                  if(devid==23)
                {
                    TextArea2.append("\nInput character to register from MAR");
                    r[rr]=Integer.valueOf(R3Textfield.getText());
                }                              
                 if(devid==24)
                {
                    TextArea2.append("\nInput character to register from PC");
                    r[rr]=Integer.valueOf(PCTextfield.getText());
                }                
                 if(devid==25)
                {
                    TextArea2.append("\nInput character to register from CC");
                    r[rr]=Integer.valueOf(CCTextfield.getText());
                }                
                 if(devid==26)
                {
                    TextArea2.append("\nInput character to register from IX");
                    r[rr]=Integer.valueOf(IXTextfield.getText());
                }                
                 if(devid==27)
                {
                    TextArea2.append("\nInput character to register from X1");
                    r[rr]=Integer.valueOf(X1Textfield.getText());
                }                
                 if(devid==28)
                {
                    TextArea2.append("\nInput character to register from X2");
                    r[rr]=Integer.valueOf(X2Textfield.getText());
                }                
                 if(devid==29)
                {
                    TextArea2.append("\nInput character to register from X2");
                    r[rr]=Integer.valueOf(X3Textfield.getText());
                }                
                 if(devid==30)
                {
                    TextArea2.append("\nInput character to register from OPCODE");
                    r[rr]=Integer.valueOf(OPCODETextfield.getText());
                }                
                 if(devid==31)
                {
                    TextArea2.append("\nInput character to register from MEMORY ADDRESS");
                    r[rr]=Integer.valueOf(AddressTextfield.getText());
                }                
                 
                  else
                    TextArea2.append("\nCannot execute IN instruction for the entered device id");
            }
            }
            
            if(opdec==62)   //OUT instruction
            {
                TextArea2.append("\nExecuting OUT instruction");
                int devid=Integer.parseInt(instruction.substring(11,16),2);
                if(devid==1)
                {
                    TextArea2.append(""+(char)r[rr]);
                }
                if(devid==4)
                {
                    IRTextField.setText(""+r[rr]);
                }
                if(devid==5)
                {
                    MARTextField.setText(""+r[rr]);
                }
                if(devid==6)
                {
                    MBRTextField.setText(""+r[rr]);
                }
                if(devid==7)
                {
                    MFRTextField.setText(""+r[rr]);
                }
                if(devid==8)
                {
                    MSRTextField.setText(""+r[rr]);
                }                
              
                if(devid==20)
                {
                    R0Textfield.setText(""+r[rr]);
                }                
                 if(devid==21)
                {
                    R1TextField.setText(""+r[rr]);
                }                               
                 if(devid==22)
                {
                    R2Textfield.setText(""+r[rr]);
                }                               
                  if(devid==23)
                {
                    R3Textfield.setText(""+r[rr]);
                     }                              
                 if(devid==24)
                {
                    PCTextfield.setText(""+r[rr]);
                }                
                 if(devid==25)
                {
                    CCTextfield.setText(""+r[rr]);
                }                
                 if(devid==26)
                {
                    IXTextfield.setText(""+r[rr]);
                  }                
                 if(devid==27)
                {
                    X1Textfield.setText(""+r[rr]);
                 }                
                 if(devid==28)
                {
                    X2Textfield.setText(""+r[rr]);
                 }                
                 if(devid==29)
                {
                    X3Textfield.setText(""+r[rr]);
                     }                
                 if(devid==30)
                {
                    OPCODETextfield.setText(""+r[rr]);
                                   }                
                 if(devid==31)
                {
                    AddressTextfield.setText(""+r[rr]);
                }                
                
               
            }
            
            if(opdec==63)    //CHK instruction
            {
               int devid=Integer.parseInt(instruction.substring(11,16),2);
               if(devid==0)
               {
                   TextArea2.append("\nChecking status of keyboard");
                   if(TextArea.getText().equals(""))
                   {
                       TextArea2.setText("\nKeyboard is ready for input");
                       r[rr]=1;
                   }
                   else
                   {
                       TextArea2.setText("\nKeyboard is not ready for input, press clear");
                       r[rr]=0;
                   }
               }
               if(devid==1)
               {
                   TextArea.append("\nChecking status of printer");                   
                  if(TextArea2.getText().equals(""))
                  {
                   TextArea.append("\nPrinter is ready");                   
                      r[rr]=1;
                  }
                   else
                  {
                   TextArea.append("\nPrinter is busy");                   
                      r[rr]=0;
                  }
               }
               else
                   TextArea.append("\nInvalid device ID");                   
               
            }
            if(opdec==33)       //Float add operation
            {
                TextArea.append("\nExecuting floating add operation");
                frr=rr;
                if(frr!=0 && frr!=1)
                    TextArea.append("\ninvalid float register");
                else
                {
                TextArea.append("\nContent of fr["+frr+"]:"+fr[frr]);    
                String value=fr[frr];
                int sign=Integer.parseInt(value.substring(0,1));
                int exsign=Integer.parseInt(value.substring(1,2));
                int exponent=Integer.parseInt(value.substring(2,8),2);
                int mantissa=Integer.parseInt(value.substring(8,16),2);
                
                if(exsign==0)
                    exp=exponent;
                if(exsign==1)
                {
                    exponent=Integer.parseInt(value.substring(1,8));
                    exp=exponent-128;
                }
                
                float m1=Integer.parseInt(value.substring(8,9));
                float m2=(float) (Integer.parseInt(value.substring(9,10))*0.5);
                float m3=(float) (Integer.parseInt(value.substring(10,11))*0.25);
                float m4=(float) (Integer.parseInt(value.substring(11,12))*0.125);
                float m5=(float) (Integer.parseInt(value.substring(12,13))*0.0625);
                float m6=(float) (Integer.parseInt(value.substring(13,14))*0.3125);
                float m7=(float) (Integer.parseInt(value.substring(14,15))*0.015625);
                float m8=(float) (Integer.parseInt(value.substring(15,16))*0.0078125);
                
                float mantissa1=m1+m2+m3+m4+m5+m6+m7+m8;
                
                
                if(sign==0)
                {
                   number=(float) (mantissa1*Math.pow(2, exp));
                }   
                else
                {
                    number=(float) -(mantissa1*Math.pow(2, exp));
                }
                TextArea.append("\nThat is equivalent to:"+number);    
                if(ival==0)
                {
                    ITextField.setText("0");
                    TextArea.append("\nC(EA):"+memory[ea]);
                    number2=number+(float)(memory[ea]);
                }
                else
                {
                   ITextField.setText("1");
                    TextArea.append("\nC(C(EA)):"+memory[memory[ea]]);
                   number2=number+(float)memory[memory[ea]];
                }
                TextArea.append("\nAfter adding with c[EA]:");
             
                if(number2>(1.9921875*Math.pow(2, 63)))
                 {
                     CCTextfield.setText("Overflow");
                 }
                
                double n= number2;
                double dec=n%1;
                int num=(int) (n-dec);
                String bin=Integer.toBinaryString(num);        
          
                String val = ".";
                while ( dec > 0 ) {
                        double r = n * 2;
                        if( r >= 1 ) {
                          val += "1";
                          n = r - 1;
                        }else{
                         val += "0";
                         n = r;
                        }
                    }     
                    value=(bin+""+val);
                    
                    StringBuilder sb=new StringBuilder(value);
                    sb.deleteCharAt(sb.indexOf("."));
                    value=sb.substring(0,1)+"."+sb.substring(1,sb.length());
                    while(value.length()<=8)
                    {
                        value=value+"0";
                    }
                    mantissa1=m1+m2+m3+m4+m5+m6+m7+m8;
                    double div=(number2/mantissa1);
                    exponent=(int) (Math.log(div)/Math.log(2));
                    String x=Integer.toBinaryString(exponent);
                    
                    StringBuilder sb1=new StringBuilder(value);
                    sb1.deleteCharAt(value.indexOf("."));
                    if(exponent>=0)
                    {
                            if(number2>=0)
                            {
                                String result=("00"+x+sb1);
                                fr[frr]=(result);
                            }
                            else
                            {
                                String result=("10"+x+sb1);
                                fr[frr]=(result);
                            }
                    }
                    else
                    {
                            if(number2>=0)
                            {
                                exponent+=Math.pow(2,7);
                                x=Integer.toBinaryString(exponent);
                                String result=("0"+x+sb1);
                                fr[frr]=(result);
                            }
                            else
                            {
                                exponent+=Math.pow(2,7);
                                x=Integer.toBinaryString(exponent);
                                String result=("1"+x+sb1);
                                fr[frr]=(result);
                            }
                    }
           
                }   
                 TextArea.append("\nFinal result to be stored in floating register fr["+frr+"] is "+number2+"\n Binary equivalent:"+fr[frr]);   
       }
            
            if(opdec==34)       //Float subtract operation
            {
                TextArea.append("\nExecuting floating subtract operation");
                frr=rr;
                if(frr!=0 && frr!=1)
                    TextArea.append("\ninvalid float register");
                else
                {
                TextArea.append("\nContent of fr["+frr+"]:"+fr[frr]);    
                String value=fr[frr];
                int sign=Integer.parseInt(value.substring(0,1));
                int exsign=Integer.parseInt(value.substring(1,2));
                int exponent=Integer.parseInt(value.substring(2,8),2);
                int mantissa=Integer.parseInt(value.substring(8,16),2);
                
                if(exsign==0)
                    exp=exponent;
                if(exsign==1)
                {
                    exponent=Integer.parseInt(value.substring(1,8));
                    exp=exponent-128;
                }
                
                float m1=Integer.parseInt(value.substring(8,9));
                float m2=(float) (Integer.parseInt(value.substring(9,10))*0.5);
                float m3=(float) (Integer.parseInt(value.substring(10,11))*0.25);
                float m4=(float) (Integer.parseInt(value.substring(11,12))*0.125);
                float m5=(float) (Integer.parseInt(value.substring(12,13))*0.0625);
                float m6=(float) (Integer.parseInt(value.substring(13,14))*0.3125);
                float m7=(float) (Integer.parseInt(value.substring(14,15))*0.015625);
                float m8=(float) (Integer.parseInt(value.substring(15,16))*0.0078125);
                
                float mantissa1=m1+m2+m3+m4+m5+m6+m7+m8;
                
                
                if(sign==0)
                {
                   number=(float) (mantissa1*Math.pow(2, exp));
                }   
                else
                {
                    number=(float) -(mantissa1*Math.pow(2, exp));
                }
                TextArea.append("\nThat is equivalent to:"+number);    
                if(ival==0)
                {
                    ITextField.setText("0");
                    TextArea.append("\nC(EA):"+memory[ea]);
                    number2=number-(float)(memory[ea]);
                }
                else
                {
                   ITextField.setText("1");
                    TextArea.append("\nC(C(EA)):"+memory[memory[ea]]);
                   number2=number-(float)memory[memory[ea]];
                }
                TextArea.append("\nAfter adding with c[EA]:");
                System.out.println(number2);
                if(number2>(1.9921875*Math.pow(2, 63)))
                 {
                     CCTextfield.setText("Overflow");
                 }
                
                double n= number2;
                double dec=n%1;
                int num=(int) (n-dec);
                int check=num;
                if(num<0)
                    num=-num;
                String bin=Integer.toBinaryString(num);        
          
                String val = ".";
                while ( dec > 0 ) {
                        double r = n * 2;
                        if( r >= 1 ) {
                          val += "1";
                          n = r - 1;
                        }else{
                         val += "0";
                         n = r;
                        }
                    }     
                    value=(bin+""+val);
                    
                    StringBuilder sb=new StringBuilder(value);
                    sb.deleteCharAt(sb.indexOf("."));
                    value=sb.substring(0,1)+"."+sb.substring(1,sb.length());
                    while(value.length()<=8)
                    {
                        value=value+"0";
                    }
                    mantissa1=m1+m2+m3+m4+m5+m6+m7+m8;
                    double div=(number2/mantissa1);
                    exponent=(int) (Math.log(div)/Math.log(2));
                    String x=Integer.toBinaryString(exponent);
                    
                    StringBuilder sb1=new StringBuilder(value);
                    System.out.println("sb1:"+sb1);
                    System.out.println("x:"+x);
                    sb1.deleteCharAt(value.indexOf("."));
                    if(exponent>=0)
                    {
                            if(number2>=0)
                            {
                                if(check<0){
                                    String result=("10"+x+sb1);
                                fr[frr]=(result);
                                }
                                else{
                                String result=("00"+x+sb1);
                                fr[frr]=(result);}
                            }
                            else
                            {
                                String result=("10"+x+sb1);
                                fr[frr]=(result);
                            }
                    }
                    else
                    {
                            if(number2>=0)
                            {
                                exponent+=Math.pow(2,7);
                                x=Integer.toBinaryString(exponent);
                                if(check<0){
                                String result=("1"+x+sb1);
                                fr[frr]=(result);
                                }
                                else{
                                String result=("0"+x+sb1);
                                fr[frr]=(result);}
                            }
                            else
                            {
                                exponent+=Math.pow(2,7);
                                x=Integer.toBinaryString(exponent);
                                String result=("1"+x+sb1);
                                fr[frr]=(result);
                            }
                    }
           
                }   
                 TextArea.append("\nFinal binary result to be stored in floating register fr["+frr+"] is "+number2+"\n Binary equivalent:"+fr[frr]);   
            }

            if(opdec==50)       //Loading floating register from memeory
            {
                TextArea.append("\nLoading floating register from memeory");
                frr=rr;
                if(ival==0)
                { 
                String a=  Integer.toBinaryString(memory[ea]);
                String b=  Integer.toBinaryString(memory[ea+1]);
                while(a.length()<=8)
                    a+="0";
                TextArea.append("\nValue found at C(ea):"+a);
                while(b.length()<=8)
                    b+="0";
                TextArea.append("\nValue found at C(ea+1):"+b);
                String c= a.concat(b);
                fr[frr]=c;
                TextArea.append("\nValue stored at FR["+frr+"]:"+fr[frr]);
                ITextField.setText("0");
                if(frr==0)
                    F0TextField.setText(""+fr[frr]);
                else
                    F1TextField.setText(""+fr[frr]);
                }
                
                if(ival==1)
                {
                ITextField.setText("1");
                if(memory[ea]>2048)
                {
                    TextArea.append("\nOverflow");
                    CCTextfield.setText("0");
                }
                else if(memory[ea]<0)
                {
                    TextArea.append("\nUnerflow");
                    CCTextfield.setText("1");
                }
                else{
                String a=  Integer.toBinaryString(memory[memory[ea]]);
                String b=  Integer.toBinaryString(memory[memory[ea+1]]);
                while(a.length()<=8)
                    a+="0";
                TextArea.append("\nValue found at C(ea):"+a);
                while(b.length()<=8)
                    b+="0";
                TextArea.append("\nValue found at C(ea+1):"+b);
                String c= a.concat(b);

                fr[frr]=c;
                                    
                }
                TextArea.append("\nThe value loaded in floating register fr["+frr+"] from memory is "+fr[frr]);   
                if(frr==0)
                    F0TextField.setText(""+fr[frr]);
                else
                    F1TextField.setText(""+fr[frr]);
                }
            }
            
            if(opdec==51)       //Store floating register to memeory
            {
                frr=rr;
                TextArea.append("\nStoring floating register to memeory");
                TextArea.append("\nThe content of floating register fr["+frr+"] is "+fr[frr]);
                if(ival==0)
                {
                    ITextField.setText("0");
                    String ff=fr[frr];
                    
                    String aa=ff.substring(0, 8);
                    String bb=ff.substring(8, 16);
                    int a=Integer.parseInt(aa,2);
                    int b=Integer.parseInt(bb,2);
                    memory[ea]=a;
                    memory[ea+1]=b;
                    TextArea.append("\nThe value stored at c[ea] (i.e. c["+ea+"]) is "+a);
                    TextArea.append("\nThe value stored at c[ea+1] (i.e. c["+(ea+1)+"]) is "+b);
                 }
                else
                {
                    ITextField.setText("1");
                    String ff=fr[frr];

                    String aa=ff.substring(0, 8);
                    String bb=ff.substring(8, 16);
                    int a=Integer.parseInt(aa,2);
                    int b=Integer.parseInt(bb,2);
                    memory[memory[ea]]=a;
                    memory[memory[ea+1]]=b;
                    TextArea.append("\nThe value stored at c[c[ea]] (i.e. c["+memory[ea]+"]) is "+a);
                    TextArea.append("\nThe value stored at c[c[ea+1]] (i.e. c["+memory[ea+1]+"]) is "+b);
                }
            }
           
            if(opdec==35)       //Vector add
            {
             TextArea.append("\nVector add operation");
             String value=fr[frr];
                int sign=Integer.parseInt(value.substring(0,1));
                int exsign=Integer.parseInt(value.substring(1,2));
                int exponent=Integer.parseInt(value.substring(2,8),2);
                int mantissa=Integer.parseInt(value.substring(8,16),2);
                
                if(exsign==0)
                    exp=exponent;
                if(exsign==1)
                {
                    exponent=Integer.parseInt(value.substring(1,8));
                    exp=exponent-128;
                }
                
                float m1=Integer.parseInt(value.substring(8,9));
                float m2=(float) (Integer.parseInt(value.substring(9,10))*0.5);
                float m3=(float) (Integer.parseInt(value.substring(10,11))*0.25);
                float m4=(float) (Integer.parseInt(value.substring(11,12))*0.125);
                float m5=(float) (Integer.parseInt(value.substring(12,13))*0.0625);
                float m6=(float) (Integer.parseInt(value.substring(13,14))*0.3125);
                float m7=(float) (Integer.parseInt(value.substring(14,15))*0.015625);
                float m8=(float) (Integer.parseInt(value.substring(15,16))*0.0078125);
                
                float mantissa1=m1+m2+m3+m4+m5+m6+m7+m8;
                
                
                if(sign==0)
                {
                   number=(float) (mantissa1*Math.pow(2, exp));
                }   
                else
                {
                    number=(float) -(mantissa1*Math.pow(2, exp));
                }
                length=(int)number;
             TextArea.append("\nVector length:"+length);
             if(ival==0)
             {
                 ITextField.setText("0");                 
                 address1=memory[ea];
                 address2=memory[ea+1];
                 TextArea.append("\nAddress of first vector:"+address1);
                 TextArea.append("\nAddress of second vector:"+address2);
                 for(int i=0;i<length;i++)
                 {
                     memory[address1]=memory[address1]+memory[address2];
                     TextArea.append("\nAdding vector V["+address1+"] with V["+address2+"]:"+memory[address1]);
                     address1++;
                     address2++;
                 }
             }
             else
             {
                 ITextField.setText("1");                 
                 address1=memory[memory[ea]];
                 address2=memory[memory[ea+1]];
                 TextArea.append("\nAddress of first vector:"+address1);
                 TextArea.append("\nAddress of second vector:"+address2);                         
                 for(int i=0;i<length;i++)
                 {
                     memory[address1]=memory[address1]+memory[address2];
                     TextArea.append("\nAdding vector V["+address1+"] with V["+address2+"]:"+memory[address1]);
                     address1++;
                     address2++;
                 }
             }

            }
            
            if(opdec==36)       //Vector Subtract
            {
             
             TextArea.append("\nVector subtract operation");
             String value=fr[frr];
                int sign=Integer.parseInt(value.substring(0,1));
                int exsign=Integer.parseInt(value.substring(1,2));
                int exponent=Integer.parseInt(value.substring(2,8),2);
                int mantissa=Integer.parseInt(value.substring(8,16),2);
                
                if(exsign==0)
                    exp=exponent;
                if(exsign==1)
                {
                    exponent=Integer.parseInt(value.substring(1,8));
                    exp=exponent-128;
                }
                
                float m1=Integer.parseInt(value.substring(8,9));
                float m2=(float) (Integer.parseInt(value.substring(9,10))*0.5);
                float m3=(float) (Integer.parseInt(value.substring(10,11))*0.25);
                float m4=(float) (Integer.parseInt(value.substring(11,12))*0.125);
                float m5=(float) (Integer.parseInt(value.substring(12,13))*0.0625);
                float m6=(float) (Integer.parseInt(value.substring(13,14))*0.3125);
                float m7=(float) (Integer.parseInt(value.substring(14,15))*0.015625);
                float m8=(float) (Integer.parseInt(value.substring(15,16))*0.0078125);
                
                float mantissa1=m1+m2+m3+m4+m5+m6+m7+m8;
                
                
                if(sign==0)
                {
                   number=(float) (mantissa1*Math.pow(2, exp));
                }   
                else
                {
                    number=(float) -(mantissa1*Math.pow(2, exp));
                }
                length=(int)number;
             TextArea.append("\nVector length:"+length);
             if(ival==0)
             {
                 ITextField.setText("0");
                 address1=Math.abs(memory[ea]);
                 address2=Math.abs(memory[ea+1]);
                 TextArea.append("\nAddress of first vector:"+address1);
                 TextArea.append("\nAddress of second vector:"+address2);
                 for(int i=0;i<length;i++)
                 {
                     memory[address1]=memory[address1]-memory[address2];
                     TextArea.append("\nSubtracting vector V["+address1+"] by V["+address2+"]:"+memory[address1]);
                     address1++;
                     address2++;
                 }
             }
             else
             {
                 ITextField.setText("1");                 
                 address1=Math.abs(memory[ea]);
                 address2=Math.abs(memory[ea+1]);
                 TextArea.append("\nAddress of first vector:"+address1);
                 TextArea.append("\nAddress of second vector:"+address2);                         
                 for(int i=0;i<length;i++)
                 {
                     memory[address1]=memory[address1]-memory[address2];
                     TextArea.append("\nSubtracting vector V["+address1+"] by V["+address2+"]:"+memory[address1]);
                     address1++;
                     address2++;
                 }
             }
           
            }
      
            if(opdec==37)       // //Converting to fixed/floating point
            {
                frr=r[rr];
                if(frr==0)      //Converting c(EA) to fixed point number
                {
                                 TextArea.append("\nConverting c(EA) to fixed point number");
                                 TextArea.append("\nc(EA): "+(double)memory[ea]);
                                 double result=((double)memory[ea]/10);
                                 TextArea.append("\nc(EA) fixed-point value (scaling factor 10): "+result);
                }
                
                else if(frr==1)           // Converting c(EA) to floating point number 
                {
                    TextArea.append("\nConverting c(EA) to floating point number ");
                    TextArea.append("\nc(EA): "+memory[ea]);
                    int n=Math.abs(memory[ea]);
                    String numbin=Integer.toBinaryString(n);
                    int length=numbin.length();
                    int exp=length-1;
                    String exponent=Integer.toBinaryString(exp);
                    while(exponent.length()<=7)
                        exponent="0"+exponent;
                    while(numbin.length()<=8)
                        numbin+="0";
                    String mantissa=numbin;
                    String sign = null;
                    if(n<0)
                        sign="1";
                    if(n>0)
                        sign="0";
                    
                    TextArea.append("\nSign:"+sign);
                    TextArea.append("\nExponent:"+exponent);
                    TextArea.append("\nMantissa:"+mantissa);
                    fr[0]=sign+exponent+mantissa;
                    TextArea.append("\nFloating point value stored in FR0:"+fr[0]);
                    
                    
                }
            }
    }//GEN-LAST:event_StartButton1ActionPerformed

    private void R0RadioButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_R0RadioButtonActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_R0RadioButtonActionPerformed

    private void HaltButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_HaltButton1ActionPerformed
     TextArea2.append("\nMachine is stopped...");
    }//GEN-LAST:event_HaltButton1ActionPerformed

    private void ClearButtonActionPerformed(java.awt.event.ActionEvent evt) {                                            
        TextArea.setText("");
        TextArea2.setText("");
    }                                            

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
      String newadd=AddressTextField1.getText();
      int newadd1=Integer.parseInt(newadd,2);
      int data=Integer.valueOf(DataTextField.getText());
      memory[newadd1]=data;
      TextArea2.append("\n"+data+" is stored in address "+newadd+" successfully");
      
    }//GEN-LAST:event_jButton1ActionPerformed

    
    private void SingleStepButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SingleStepButtonActionPerformed
        
    }//GEN-LAST:event_SingleStepButtonActionPerformed

    private void SingleStepButtonMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_SingleStepButtonMouseClicked
     String instruction = new String("0000010100010000"); 
        if(evt.getClickCount()==1)
        { TextArea2.append("\n"+instruction);
        ipl(instruction);
        }
        if(evt.getClickCount()==2)
        {   instruction = "0000011001010001"; 
        TextArea2.append("\n"+instruction); 
       ipl(instruction);
        }
       if(evt.getClickCount()==3) 
       { instruction = "0000010000101000"; 
       TextArea2.append("\n"+instruction); 
       ipl(instruction);
       }
       if(evt.getClickCount()==4) 
       {instruction = "0000101000001110"; 
       TextArea2.append("\n"+instruction); 
       ipl(instruction);
       }
       if(evt.getClickCount()==5) 
       {instruction = "0000111101000111"; 
       TextArea2.append("\n"+instruction); 
       ipl(instruction);
       }
       if(evt.getClickCount()==6) 
       {instruction = "1010010001010001"; 
       TextArea2.append("\n"+instruction); 
       ipl(instruction);
       }
        
    }//GEN-LAST:event_SingleStepButtonMouseClicked

    private void PCTextfieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PCTextfieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_PCTextfieldActionPerformed

    private void Program1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Program1ActionPerformed
IRTextField.setText("0000000000000000");
        int address=1000;
        int flag=1;
        for(int j=1021;j<=1040;j++)
           {
              memory[j]=-1;                   
           }
        for(String number:TextArea.getText().split("\\n"))
        {
          if(number.matches(".*\\d.*"))
            {
                    memory[address]=Integer.valueOf(number);
                   
                    //r[0]=Integer.valueOf(number);
                    //storeregister(00,address,0);
                    //storeregister1(00,address);
                    address++;
            }
          else
          {
              TextArea2.append("\nWrong input");
              flag=0;
              break;
          }
        }
        if(flag==1)  
        {
            TextArea2.append("\nThe entered numbers are:");
        for(int i=1000;i<=1019;i++)
        {
            TextArea2.append(memory[i]+" ");
        }
        TextArea2.append("\nThe number to find the closest: "+memory[1020]);
      
       
        try{
            BufferedReader in=new BufferedReader(new FileReader("./src/simulator/instruction.txt"));
            String str;
            while ((str = in.readLine()) != null)
            {
                String inst[]=(str.split(" "));
                if(inst[0].equals("LDR"))
                {
                    if(inst[1].equals("R0"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        loadregister(00, ea1, 0);
                     
                    }
                    if(inst[1].equals("R1"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        loadregister(01, ea1, 0);
                      
                    } 
                    if(inst[1].equals("R2"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        loadregister(10, ea1, 0);       
                        TextArea2.append("\nLDR \n "+r[2]+" = "+ "\n Memory[ "+ea1+"]="+memory[ea1]+"\n");
                    }
                    if(inst[1].equals("R3"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        loadregister(11, ea1, 0);                        
                    }
                }
                if(inst[0].equals("STR"))
                {
                    if(inst[1].equals("R0"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        storeregister(00, ea1, 0);
                        //storeregister1(00, ea1);
                    }
                    if(inst[1].equals("R1"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        storeregister(01, ea1, 0);
                        //storeregister1(01, ea1);
                    } 
                    if(inst[1].equals("R2"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        storeregister(10, ea1, 0);
                        TextArea2.append("\nSTR \n memory["+ea1+"]=r[2]="+r[2]+"\n");
                    }
                    if(inst[1].equals("R3"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        //storeregister1(11, ea1);
                        storeregister(11, ea1, 0);                        
                    }
                }    
                if(inst[0].equals("ABS"))
                {
                    if(inst[1].equals("R0"))
                    {
                        absfunc(00);
                    }
                    if(inst[1].equals("R1"))
                    {
                        absfunc(01);
                    } 
                    if(inst[1].equals("R2"))
                    {
                        absfunc(10);
                        TextArea2.append("\nABS "+"\n");

                        
                    }
                    if(inst[1].equals("R3"))
                    {
                        absfunc(11);
                    }
                }
                if(inst[0].equals("SMR"))
                {
                    if(inst[1].equals("R0"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        submemfromreg(00,ea1,0);
                        //subtract1(00, ea1);
                    }
                    if(inst[1].equals("R1"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        submemfromreg(01,ea1,0);
                        //subtract1(01, ea1);
                    } 
                    if(inst[1].equals("R2"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        int subNumber = submemfromreg(10,ea1,0);
                        TextArea2.append("\nSMR \nr[2]=r[2]-c["+ea1+"]="+r[2]+"-"+memory[ea1]+"="+ subNumber+"\n");
                       
                    }
                    if(inst[1].equals("R3"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        submemfromreg(11,ea1,0);
                        //subtract1(11, ea1);
                    }                    
                }
                if(inst[0].equals("CPR"))
                {
                    if(inst[1].equals("R0"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        if(r[0]>=memory[ea1])
                        {
                            r[0]=memory[ea1];
                            memory[k]=ea1;
                            k++;
                         
                        }
                        else if(r[0]<memory[ea1])
                        {
                            in.skip(12);
                        }
                    }
                    if(inst[1].equals("R1"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        if(r[1]>=memory[ea1])
                        {
                            r[1]=memory[ea1];
                            memory[k]=ea1;
                            k++;
                        }
                        else if(r[1]<memory[ea1])
                        {
                            in.skip(12);
                        }       
                    } 
                    if(inst[1].equals("R2"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        if(r[2]>=memory[ea1])
                        {
                            r[2]=memory[ea1];
                            memory[k]=ea1;
                            k++;
                            TextArea2.append("\nCPR \n(r[2]>=memory["+ea1+"]"+r[2]+">"+memory[ea1]+"\n");
                        }
                        else if(r[2]<memory[ea1])
                        {
                            in.skip(12);
                        }
                    }
                    if(inst[1].equals("R3"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        if(r[3]>=memory[ea1])
                        {
                            r[3]=memory[ea1];
                            memory[k]=ea1;
                            k++;
                        }
                        else if(r[3]<memory[ea1])
                        {
                            in.skip(12);
                        }             
                    }                    
                }
                
            }
            TextArea2.append("\nr[2]="+r[2]);
            
            for(int i=1050;i<=1069;i++) {
            	
            	if(memory[i]==r[2]) {
            		
            		TextArea2.append("\n the closest number is"+memory[i-50]);
            	}
            }
        }
        
        catch(IOException e){
        }
     }}
        
/**int difference=Math.abs(memory[1020]-memory[1000]);
int index=0;
TextArea2.append("\nClosest number or numbers:");
for(int i=1001;i<=1019;i++)        
{
    if((Math.abs(memory[1020]-memory[i]))<difference)
    {
        difference=Math.abs(memory[1020]-memory[i]);
        index=i;
        k++;
    }
}   

for(int i=1001;i<=1019;i++)        
{
    if((Math.abs(memory[1020]-memory[i]))==difference)
    {
        TextArea2.append(" "+memory[i]);
    }
}

    }//GEN-LAST:event_Program1ActionPerformed
    */

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        TextArea.append("Press 'Clear' button then\n Enter 20  numbers and the number to find the closest:\n");
    }//GEN-LAST:event_jButton2ActionPerformed

    private void Program2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Program2ActionPerformed
IRTextField.setText("0000000000000000");
try{
            BufferedReader in=new BufferedReader(new FileReader("C:/Users/prave/OneDrive/Documents/NetBeansProjects/Simulator/src/simulator/instruction2.txt"));
            String str;
            while ((str = in.readLine()) != null)
            {
                String inst[]=(str.split(" "));
                if(inst[0].equals("LDR"))
                {
                    if(inst[1].equals("0"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                       
                            loadregister(00,ea1,0);
                    }
                    if(inst[1].equals("1"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                            loadregister(01,ea1,0);                      
                    } 
                    if(inst[1].equals("2"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                            loadregister(10,ea1,0);
                        TextArea2.append("\nLDR \n "+r[2]+" = "+ "\n Memory[ "+ea1+"]="+memory[ea1]+"\n");
                    }
                    if(inst[1].equals("3"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                            loadregister(11,ea1,0);                    }
                }
                if(inst[0].equals("STR"))
                {
                    if(inst[1].equals("0"))
                    { int ea1=Integer.valueOf(inst[2]);
                            storeregister(00,ea1,0);
                    }
                    if(inst[1].equals("1"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                            storeregister(01,ea1,0);
                    } 
                    if(inst[1].equals("2"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                            storeregister(10,ea1,0);
                        TextArea2.append("\nSTR \n memory["+ea1+"]=r[2]="+r[2]+"\n");
                    }
                    if(inst[1].equals("3"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                            storeregister(11,ea1,0);                        
                    }
                }
                
                if(inst[0].equals("LDA"))
                {
                  if(inst[1].equals("0"))
                    {
                        int ea1=Integer.parseInt(inst[2]);
                        loadregadd(00, ea1);
                    }
                    if(inst[1].equals("1"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        loadregadd(01, ea1);
                    } 
                    if(inst[1].equals("2"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        loadregadd(10, ea1);
                    }
                    if(inst[1].equals("3"))
                    {
                        int ea1=Integer.valueOf(inst[2]);
                        loadregadd(11, ea1);                        
                    }  
                }
            
                if(inst[0].equals("MLT"))
                {
                  int rx=Integer.valueOf(inst[1]);
                  int ry=Integer.valueOf(inst[2]);
                  int x=r[rx];
                  int y=r[ry];
                  multiplyregister(x, y, rx);
                }
            
                if(inst[0].equals("OUT"))
                {
                    TextArea2.append(""+r[0]);
                }
                
                if(inst[0].equals("AIR"))
                {
                    int rr=Integer.valueOf(inst[1]);
                    int imm=Integer.valueOf(inst[2]);
                    if(rr==0)
                     addimmtoreg(00, imm);
                    if(rr==1)
                     addimmtoreg(01, imm);
                    if(rr==2)
                     addimmtoreg(10, imm);
                    if(rr==3)
                     addimmtoreg(11, imm);
                }
                
                if(inst[0].equals("SIR"))
                {
                    int rr=Integer.valueOf(inst[1]);
                    int imm=Integer.valueOf(inst[2]);
                    if(rr==0)
                     subimmtoreg(00, imm);
                    if(rr==1)
                     subimmtoreg(01, imm);
                    if(rr==2)
                     subimmtoreg(10, imm);
                    if(rr==3)
                     subimmtoreg(11, imm);
                }
                
                if(inst[0].equals("TRR"))
                {
                    int rx=Integer.valueOf(inst[1]);
                    int ry=Integer.valueOf(inst[2]);
                    int x=r[rx];
                    int y=r[ry];
                    TextArea2.append("\nTesting equality between registerss R"+rx+" and R"+ry);
                    if(x==y)
                    {
                        cc[3]=1;
                        CCTextfield.setText("EQUAL");
                        TextArea2.append("\nBoth registers are equal");
                    }
                    else
                    {
                        cc[3]=0;
                        CCTextfield.setText("NOT EQUAL");
                        TextArea2.append("\nBoth registers are not equal");
                    }
                }
                
                if(inst[0].equals("JCC"))
                {
                    TextArea2.append("\nExecuting JCC instruction");
                }

                if(inst[0].equals("JMP"))
                {
                    TextArea2.append("\nExecuting JMP instruciton");
                }                   
}
}
            catch(IOException e){
    
}
prg2();
    }//GEN-LAST:event_Program2ActionPerformed

    
    
    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed

        try{
    BufferedReader buf=new BufferedReader(new FileReader("C:/Users/prave/OneDrive/Documents/NetBeansProjects/Simulator/src/simulator/paragraph.txt"));
    String sentence;
    int s = 0,i;
    String[] ar = null;
    String search=TextArea2.getText();
    TextArea2.append("\nThe sentences are:\n");
    while((sentence=buf.readLine())!=null)
    {
        ar=sentence.split("\\.");            
    }
    for(i=0;i<ar.length;i++)
    {
      TextArea2.append("\n"+ar[i]);
    }
        }
        catch(IOException e)
        {
            
        }






    }//GEN-LAST:event_jButton3ActionPerformed

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed
TextArea2.append("Instructions:\n-Click button 'See the sentences in the paragraph' to print the sentences in the paragraph.\n-Enter the word to be searched in the keyboard.\n-Click 'Run program 2'.\n");
//TextArea2.append("\n-Follow these steps after clicking clear button");


    }//GEN-LAST:event_jButton4ActionPerformed

    private void CCTextfieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CCTextfieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_CCTextfieldActionPerformed

    /**
     * @param args the command line arguments
     */
       
    public static void main(String args[]) {
        int i;
        for(i=0;i<memory.length;i++)
        {
            memory[i]=i;
        }
        for(i=0;i<r.length;i++)
        {
            r[i]=i;
        }
        ixarray[0]=0;
        ixarray[1]=0;
        ixarray[2]=0;
        java.awt.EventQueue.invokeLater(new Runnable() {
           public void run() {
              new gui().setVisible(true);
         }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField AddressTextField1;
    private javax.swing.JTextField AddressTextfield;
    private javax.swing.JTextField CCTextfield;
    private javax.swing.JButton ClearButton;
    private javax.swing.JTextField DataTextField;
    private javax.swing.JTextField F0TextField;
    private javax.swing.JTextField F1TextField;
    private javax.swing.JButton HaltButton1;
    private javax.swing.JButton IPLButton;
    private javax.swing.JTextField IRTextField;
    private javax.swing.JTextField ITextField;
    private javax.swing.JTextField IXTextfield;
    private javax.swing.JTextField IXTextfield1;
    private javax.swing.JTextField MARTextField;
    private javax.swing.JTextField MBRTextField;
    private javax.swing.JTextField MFRTextField;
    private javax.swing.JTextField MSRTextField;
    private javax.swing.JTextField OPCODETextfield;
    private javax.swing.JTextField PCTextfield;
    private javax.swing.JButton Program1;
    private javax.swing.JButton Program2;
    private javax.swing.JRadioButton R0RadioButton;
    private javax.swing.JTextField R0Textfield;
    private javax.swing.JRadioButton R1RadioButton;
    private javax.swing.JTextField R1TextField;
    private javax.swing.JRadioButton R2RadioButton;
    private javax.swing.JTextField R2Textfield;
    private javax.swing.JRadioButton R3RadioButton;
    private javax.swing.JTextField R3Textfield;
    private javax.swing.JButton SingleStepButton;
    public javax.swing.JButton StartButton1;
    public javax.swing.JTextArea TextArea;
    private javax.swing.JTextArea TextArea2;
    public javax.swing.JTextField X1Textfield;
    public javax.swing.JTextField X1Textfield1;
    private javax.swing.JTextField X2Textfield;
    public javax.swing.JTextField X2Textfield1;
    private javax.swing.JTextField X3Textfield;
    public javax.swing.JTextField X3Textfield1;
    private javax.swing.JTextField instructiontext;
    public javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel19;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel20;
    private javax.swing.JLabel jLabel21;
    private javax.swing.JLabel jLabel22;
    private javax.swing.JLabel jLabel23;
    private javax.swing.JLabel jLabel24;
    private javax.swing.JLabel jLabel25;
    private javax.swing.JLabel jLabel26;
    private javax.swing.JLabel jLabel27;
    private javax.swing.JLabel jLabel28;
    private javax.swing.JLabel jLabel29;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel30;
    private javax.swing.JLabel jLabel31;
    private javax.swing.JLabel jLabel32;
    private javax.swing.JLabel jLabel33;
    private javax.swing.JLabel jLabel34;
    private javax.swing.JLabel jLabel35;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    // End of variables declaration//GEN-END:variables

   public int effectiveaddress(int ival, int ix, int address) {
       int ea = 0;                                            
//       int decaddress=Integer.parseInt(binaryaddress,2);
       //Calculating EA
       if(ival==0)                      //When I=0                                                     
        {   
            if(ix==0)                               //when IX=0
               ea=address;
            if(ix==1)                               //when IX=1        
               ea=(address+ixarray[0]);
            if(ix==2)                               //when IX=2    
               ea=(address+ixarray[1]);
            if(ix==3)                               //when IX=3;
               ea=(address+ixarray[2]);
        }
        else                                        //when I=1
        {
            if(ix==0)
               ea =memory[address];
            if(ix==1)
               ea=memory[ixarray[0]+address];
            if(ix==2)
               ea=memory[ixarray[1]+address];
            if(ix==3)
               ea=memory[ixarray[2]+address];
         }
       return ea;
    }

  //LDR instruction execution 
    public void loadregister(int reg,int ea,int ival) {
         
    	String eabinary=Integer.toBinaryString(ea);
    	TextArea2.append("\nLoading instruction,  the effective address is "+eabinary);
    
        int effaddr=ea/6;//effaddr equals to the number of block
        int memIndex=ea%6; //memIndex is the position of Word in a block
        String eabin=Integer.toBinaryString(effaddr);
         while (eabin.length() < 16) {
            eabin = "0" + eabin;
        }
        int CachelineIndex=Integer.parseInt(eabin.substring(13,16),2);
        int tag=Integer.parseInt(eabin.substring(0,13),2);
      
   //if the address can be found in cache  
        if(tag==cache1.cacheline[CachelineIndex].getTag())
        {
    
        	TextArea2.append("\nThe word is in block"+ effaddr +"in the memory");
        	TextArea2.append("\nThe word is the"+ memIndex +"number in the block ");
        	TextArea2.append("\nThe word can be found in cacheline"+ CachelineIndex);
        	
   //present bit = 1, which means the number can be found in cache.
            int p=1;
            cache1.cacheline[CachelineIndex].setPresent(p);
            TextArea2.append("\nSet the present bit = 1");
            
   //write bit = 0; which means no word is modified.         
            TextArea2.append("\nTAG bits remain the same");
            
   //load the number from cacheline
            if( ival == 0){//no indirect addressing in the instruction
   			 
   			 
   			 if (reg == 00){
   				 TextArea2.append("\nNo indirect addressing...");
   				 r[0]=cache1.cacheline[CachelineIndex].getWord(memIndex);
   				 TextArea2.append("\nLoad "+" Word "+r[0]
           			+" to register[0]");
   				 R0Textfield.setText(""+r[0]);
   			 }
   			 
            
   			 if (reg == 01){
   				 TextArea2.append("\nNo indirect addressing...");
   				 r[1]=cache1.cacheline[CachelineIndex].getWord(memIndex);
   				 TextArea2.append("\nLoad "+" Word "+r[1]
           			+" to register[1]");
   				 R1TextField.setText(""+r[1]);
   			 }
   			 
            
   			 if (reg == 10){
   				 TextArea2.append("\nNo indirect addressing...");
   				 r[2]=memory[ea];
   				 TextArea2.append("\nLoad "+" Word "+r[2]
           			+" to register[2]");
   				 int number= (tag*8+CachelineIndex)*6;
   				 R2Textfield.setText(""+r[2]);
   				
   				 
   			 }
   			 
   			 
   			 if (reg == 11){
   				 TextArea2.append("\nNo indirect addressing...");
   				 r[3]=cache1.cacheline[CachelineIndex].getWord(memIndex);
   				 TextArea2.append("\nLoad "+" Word "+r[3]
           			+" to register[3]");
   				 R3Textfield.setText(""+r[3]);
   			 }
   			 
   			 
   		 }
   		 

   		 if( ival == 1){// indirect addressing in the instruction
   			 
   			 if (reg == 00){
   				 TextArea2.append("\nIndirect addressing...");
   				 int wordNum = cache1.cacheline[CachelineIndex].getWord(memIndex);
   				 
   				 if(wordNum <= 2047){
   					 r[0]=memory[wordNum];
   					 TextArea2.append("\nLoad "+" Word "+r[0]
   							 +" to register[0]");
   					 R0Textfield.setText(""+r[0]);
   				 }else{
   					 TextArea2.append("\nThe address number is larger than 2047 ");
                                         msr = 3;
                                         TextArea2.append("\nIllegal TRAP code, machine fault: 3 ");
                                         MFRTextField.setText("3");
   				 }
   			 }
            
   			 
   			 if (reg == 01){
   				 TextArea2.append("\nIndirect addressing...");
   				 int wordNum = cache1.cacheline[CachelineIndex].getWord(memIndex);
   				 
   				 if(wordNum <= 2047){
   					 r[1]=memory[wordNum];
   				 TextArea2.append("\nLoad "+" Word "+r[1]
           			+" to register[1]");
   				 R1TextField.setText(""+r[1]);
   				
   				 }else{
   					 TextArea2.append("\nThe address number is larger than 2047 ");
   				 }
   			 }
            
   			 if (reg == 10){
   				 TextArea2.append("\nIndirect addressing...");
   				 int wordNum = cache1.cacheline[CachelineIndex].getWord(memIndex);
   				 
   				 if(wordNum <= 2047){
   					 r[2]=memory[wordNum];
   				 TextArea2.append("\nLoad "+" Word "+r[2]
           			+" to register[2]");
   				 R2Textfield.setText(""+r[2]);
   				 }else{
   					 TextArea2.append("\nThe address number is larger than 2047 ");
   				 }
   			 }
   			 
   			 if (reg == 11){
   				 TextArea2.append("\nDirect addressing...");
   				 int wordNum = cache1.cacheline[CachelineIndex].getWord(memIndex);
   				 
   				 if(wordNum <= 2047){
   					 r[3]=memory[wordNum];
   				 TextArea2.append("\nLoad "+" Word "+r[3]
           			+" to register[3]");
   				 R3Textfield.setText(""+r[3]);
   				 }else{
   					 TextArea2.append("\nThe address number is larger than 2047 ");
   				 }
   			 }
   		 }
        }else if(tag!=cache1.cacheline[CachelineIndex].getTag()){
   //if the address cannot be found in cache
        	
        	 
        	 TextArea2.append("\nThe word is in block "+ effaddr +" in the memory");
         	 TextArea2.append("\nThe word is the "+ memIndex +" number in the block");
         	 TextArea2.append("\nThe word cannot be found in cacheline "+ CachelineIndex);
    //if  w == 1,  means the data in block have been modified,
    //write back the whole cacheline to memory.
 
      	 if( cache1.cacheline[CachelineIndex].getWrite()==1){
        		 
        		 TextArea2.append("\nIn cacheline "+ CachelineIndex+" the data have been modified");
        		 
        		 //Copy the present block in cacheline to block in memory
        		 //using write back strategy
        		 int startAddress= (cache1.cacheline[CachelineIndex].getTag() * 
        				
        				 cache1.cache_length + CachelineIndex)*
        				 
        				 cache1.words_per_line;
        		 
        		 
        		 for(int iPara=0; iPara<cache1.words_per_line; iPara++){
        			 
        		 memory[startAddress+iPara]=cache1.cacheline[CachelineIndex].getWord(iPara);
        		 
        		 }
        		 
        		 int blockNumber = cache1.cacheline[CachelineIndex].getTag()*
        				 cache1.cache_length + CachelineIndex;
        		 
        		 TextArea2.append("\nCopy the cacheline "+ CachelineIndex +" to block" +
        				 blockNumber+" in memory");
        		 
        		 //Copy new block from memory
        		 int copyFromAddress= (tag *
        				 
        				 cache1.cache_length + CachelineIndex) * cache1.words_per_line;
        		 
        		 for(int iPara=0; iPara<cache1.words_per_line; iPara++){
        			 
            		 cache1.cacheline[CachelineIndex].setWord(memory[copyFromAddress+iPara],iPara);
            		 }
        		 
        		 int blockNumber2=tag * cache1.cache_length + CachelineIndex;
        		 TextArea2.append("\nLoad block "+ blockNumber2 +" from memory to cacheline" +
        				 CachelineIndex);
        		 
        		 //set TAG,present bit and write bit
        		 //tag is the integer derived from effective address;
        		 
        		 cache1.cacheline[CachelineIndex].setTag(tag);
        		 TextArea2.append("\nSet new TAG number " + tag);
        		 
        		//present bit = 1, which means the number can be found in cache.
        		 int p=1;
        		 cache1.cacheline[CachelineIndex].setPresent(p);
        		 TextArea2.append("\nSet present bit = 1");
        		 
        		//write bit = 0; which means no word is modified.         
        		 int w=0;
        		 cache1.cacheline[CachelineIndex].setWrite(w);
        		 TextArea2.append("\nSet write bit = 0");
        		 
        		 //load the number from cacheline
        		
        		 if( ival == 0){//no indirect addressing in the instruction
        			 
        			 
        			 if (reg == 00){
        				 TextArea2.append("\nNo indirect addressing...");
        				 r[0]=cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 TextArea2.append("\nLoad "+" Word "+r[0]
                			+" to register[0]");
        				 R0Textfield.setText(""+r[0]);
        				
        			 }
        			 
                 
        			 if (reg == 01){
        				 TextArea2.append("\nNo indirect addressing...");
        				 r[1]=cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 TextArea2.append("\nLoad "+" Word "+r[1]
                			+" to register[1]");
        				 R1TextField.setText(""+r[1]);
        			 }
        			 
                 
        			 if (reg == 10){
        				 TextArea2.append("\nNo indirect addressing...");
        				 r[2]=cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 TextArea2.append("\nLoad "+" Word "+r[2]
                			+" to register[2]");
        				 R2Textfield.setText(""+r[2]);
        			 }
        			 
        			 
        			 if (reg == 11){
        				 TextArea2.append("\nNo indirect addressing...");
        				 r[3]=cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 TextArea2.append("\nLoad "+" Word "+r[3]
                			+" to register[3]");
        				 R3Textfield.setText(""+r[3]);
        			 }
        			 
        			 
        		 }
        		 

        		 if( ival == 1){// indirect addressing in the instruction
        			 
        			 if (reg == 00){
        				 TextArea2.append("\nIndirect addressing...");
        				 int wordNum = cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 
        				 if(wordNum <= 2047){
        					 r[0]=memory[wordNum];
        					 TextArea2.append("\nLoad "+" Word "+r[0]
        							 +" to register[0]");
        					 R0Textfield.setText(""+r[0]);
        				 }else{
        					 TextArea2.append("\nThe address number is larger than 2047 ");
        				 }
        			 }
                 
        			 
        			 if (reg == 01){
        				 TextArea2.append("\nIndirect addressing...");
        				 int wordNum = cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 
        				 if(wordNum <= 2047){
        					 r[1]=memory[wordNum];
        				 TextArea2.append("\nLoad "+" Word "+r[1]
                			+" to register[1]");
        				 R1TextField.setText(""+r[1]);
        				 
        				 }else{
        					 TextArea2.append("\nThe address number is larger than 2047 ");
        				 }
        			 }
                 
        			 if (reg == 10){
        				 TextArea2.append("\nIndirect addressing...");
        				 int wordNum = cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 
        				 if(wordNum <= 2047){
        					 r[2]=memory[wordNum];
        				 TextArea2.append("\nLoad "+" Word "+r[2]
                			+" to register[2]");       				
        				 R2Textfield.setText(""+r[2]);
        				 
        				 }else{
        					 TextArea2.append("\nThe address number is larger than 2047 ");
        				 }
        			 }
        			 
        			 if (reg == 11){
        				 TextArea2.append("\nIndirect addressing...");
        				 int wordNum = cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 
        				 if(wordNum <= 2047){
        					 r[3]=memory[wordNum];
        				 TextArea2.append("\nLoad "+" Word "+r[3]
                			+" to register[3]");
        				 R3Textfield.setText(""+r[3]);
        				 
        				 }else{
        					 TextArea2.append("\nThe address number is larger than 2047 ");
        				 }
        			 }
        		 }

        		 
    	 }else if(cache1.cacheline[CachelineIndex].getWrite()==0){
        		 //In this condition, no word is modified in the cacheline[index], so the only thing 
        		 //to do is to copy the corresponding block into cache.
        		 TextArea2.append("\nIn cacheline "+ CachelineIndex+" the data have not been modified");
        		 //Copy new block from memory
        		 int copyFromAddress= (tag * cache1.cache_length + CachelineIndex) * cache1.words_per_line;
        		 for(int iPara=0; iPara<cache1.words_per_line; iPara++){
        	
            		 cache1.cacheline[CachelineIndex].setWord(memory[copyFromAddress+iPara],iPara);
            	
            		 }
        		 int blockNumber3 = tag * cache1.cache_length + CachelineIndex;
        		 TextArea2.append("\nLoad block "+ blockNumber3 +" from memory to cacheline" +
        				 CachelineIndex);
        		 //set TAG,present bit and write bit
        		 //tag is the integer derived from effective address;
        		 
        		 cache1.cacheline[CachelineIndex].setTag(tag);
        		 TextArea2.append("\nSet new TAG number" + tag);
        		 
        		//present bit = 1
        		 int p=1;
        		 cache1.cacheline[CachelineIndex].setPresent(p);
        		 TextArea2.append("\nSet present bit = 1");
        		 
        		//write bit = 0; which means no word is modified.         
        		 int w=0;
        		 cache1.cacheline[CachelineIndex].setWrite(w);
        		 TextArea2.append("\nSet write bit = 0");
        		 
        		 //load the number from cacheline
                 
                 
               
        		 if( ival == 0){//no indirect addressing in the instruction
        			 
        			 
        			 if (reg == 00){
        				 TextArea2.append("\nNo indirect addressing...");
        				 r[0]=cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 TextArea2.append("\nLoad "+" Word "+r[0]
                			+" to register[0]");
        				 R0Textfield.setText(""+r[0]);
        			 }
        			 
                 
        			 if (reg == 01){
        				 TextArea2.append("\nNo indirect addressing...");
        				 r[1]=cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 TextArea2.append("\nLoad "+" Word "+r[1]
                			+" to register[1]");
        				 R1TextField.setText(""+r[1]);
        			 }
        			 
                 
        			 if (reg == 10){
        				 TextArea2.append("\nNo indirect addressing...");
        				 r[2]=cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 TextArea2.append("\nLoad "+" Word "+r[2]
                			+" to register[2]");
        				 R2Textfield.setText(""+r[2]);
        				 
        			 }
        			 
        			 
        			 if (reg == 11){
        				 TextArea2.append("\nNo indirect addressing...");
        				 r[3]=cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 TextArea2.append("\nLoad "+" Word "+r[3]
                			+" to register[3]");
        				 R3Textfield.setText(""+r[3]);
        			 }
        			 
        			 
        		 }
        		 

        		 if( ival == 1){// indirect addressing in the instruction
        			 
        			 if (reg == 00){
        				 TextArea2.append("\nIndirect addressing...");
        				 int wordNum = cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 
        				 if(wordNum <= 2047){
        					 r[0]=memory[wordNum];
        					 TextArea2.append("\nLoad "+" Word "+r[0]
        							 +" to register[0]");
        					 R0Textfield.setText(""+r[0]);
        				 }else{
        					 TextArea2.append("\nThe address number is larger than 2047 ");
        				 }
        			 }
                 
        			 
        			 if (reg == 01){
        				 TextArea2.append("\nIndirect addressing...");
        				 int wordNum = cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 
        				 if(wordNum <= 2047){
        					 r[1]=memory[wordNum];
        				 TextArea2.append("\nLoad "+" Word "+r[1]
                			+" to register[1]");
        				 R1TextField.setText(""+r[1]);
        				
        				 }else{
        					 TextArea2.append("\nThe address number is larger than 2047 ");
        				 }
        			 }
                 
        			 if (reg == 10){
        				 TextArea2.append("\nIndirect addressing...");
        				 int wordNum = cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 
        				 if(wordNum <= 2047){
        					 r[2]=memory[wordNum];
        				 TextArea2.append("\nLoad "+" Word "+r[2]
                			+" to register[2]");
        				 R2Textfield.setText(""+r[2]);
        				 }else{
        					 TextArea2.append("\nThe address number is larger than 2047 ");
        				 }
        			 }
        			 
        			 if (reg == 11){
        				 TextArea2.append("\nIndirect addressing...");
        				 int wordNum = cache1.cacheline[CachelineIndex].getWord(memIndex);
        				 
        				 if(wordNum <= 2047){
        					 r[3]=memory[wordNum];
        				 TextArea2.append("\nLoad "+" Word "+r[3]
                			+" to register[3]");
        				 R3Textfield.setText(""+r[3]);
        				 }else{
        					 TextArea2.append("\nThe address number is larger than 2047 ");
        				 }
        			 }
        		 }
        	 }
        }
    }

 //STR instruction
    public void storeregister(int reg,int ea,int ival) {
          	
    	//write back policy
    	String eabinary=Integer.toBinaryString(ea);
    	TextArea2.append("\nThe effective address in this store instruction is"+eabinary);
    	TextArea2.append("\nStore register ["+ reg +"] to memory");
    	
    	if(ival==0) {
    		
    		TextArea2.append("\nno indirect addressing...");
    		int effaddr=ea/6;//effaddr equals to the number of block
            int memIndex=ea%6; //memIndex is the position of Word in a block
            String eabin=Integer.toBinaryString(effaddr);
             while (eabin.length() < 16) {
            eabin = "0" + eabin;
        }
            int CachelineIndex=Integer.parseInt(eabin.substring(13,16),2);
            int tag=Integer.parseInt(eabin.substring(0,13),2);
            
            if(tag==cache1.cacheline[CachelineIndex].getTag()){
            	
            	TextArea2.append("\nThe word is in block "+ effaddr +" in the memory");
            	TextArea2.append("\nThe word is the "+ memIndex +" number in the block ");
            	TextArea2.append("\nThe word can be found in cacheline "+ CachelineIndex);
            	
            	 //present bit = 1, which means there is valid data in the cacheline.
            	 int p=1;
                 cache1.cacheline[CachelineIndex].setPresent(p);
                 TextArea2.append("\nSet the present bit = 1");
                 
                 //write bit = 1; which means word is modified.         
                 int w=1;
                 cache1.cacheline[CachelineIndex].setWrite(w);
                 TextArea2.append("\nSet the write bit = 1");
                 
                 if (reg == 00){
        				
       				 cache1.cacheline[CachelineIndex].setWord(r[0],memIndex);
       				 TextArea2.append("\nStore r[0]= "+r[0]
               			+" to Word["+ memIndex+"] in cacheline" + CachelineIndex);
       				
       			 }
                 
                 if (reg == 01){
     				
       				 cache1.cacheline[CachelineIndex].setWord(r[1],memIndex);
       				 TextArea2.append("\nStore r[1]= "+r[1]
               			+" to Word["+ memIndex+"] in cacheline" + CachelineIndex);
       				
       			 }
                 
                 if (reg == 10){
      				
       				 cache1.cacheline[CachelineIndex].setWord(r[2],memIndex);
       				 TextArea2.append("\nStore r[2]= "+r[2]
               			+" to Word["+ memIndex+"] in cacheline" + CachelineIndex);
       				
       			 }
                 
                 if (reg == 11){
       				
       				 cache1.cacheline[CachelineIndex].setWord(r[3],memIndex);
       				 TextArea2.append("\nStore r[3]= "+r[3]
               			+" to Word["+ memIndex+"] in cacheline" + CachelineIndex);
       				
       			 }
                
            }
            
            if(tag!=cache1.cacheline[CachelineIndex].getTag()){
            	
            	TextArea2.append("\nThe memory location is not in cache");
            	TextArea2.append("\n no write allocate policy");
            	
                
            	 if (reg == 00){
            		 memory[ea]=r[0];
            		 TextArea2.append("\nwrite r[0] " +r[0] +" to memory["+ ea+"]");
                          cache1.cacheline[CachelineIndex].setWord(r[0],memIndex);
       			      
            	 }
            	 
            	 if (reg == 01){
            		 memory[ea]=r[1];
            		 TextArea2.append("\nwrite r[1] " +r[1] +" to memory["+ ea+"]");
                          cache1.cacheline[CachelineIndex].setWord(r[1],memIndex);
       				

            	 }
            	 
            	 if (reg == 10){
            		 memory[ea]=r[2];
            		 TextArea2.append("\nwrite r[2] " +r[2] +" to memory["+ ea+"]");
                          cache1.cacheline[CachelineIndex].setWord(r[2],memIndex);
       				
            	 }
            	 
            	 if (reg == 11){
            		 memory[ea]=r[3];
            		 TextArea2.append("\nwrite r[3] " +r[3] +" to memory["+ ea+"]");
                          cache1.cacheline[CachelineIndex].setWord(r[3],memIndex);
       				
       				
            	 }
    	}
        
      
    }
   		 

   		 if( ival == 1){// indirect addressing in the instruction 
   			TextArea2.append("\nIndirect addressing...");
   			int newEA = memory[ea];
   			
   			if (newEA <= 2047){
    		int effaddr=newEA/6;//effaddr equals to the number of block
            int memIndex=newEA%6; //memIndex is the position of Word in a block
            String eabin=Integer.toBinaryString(effaddr);
            int CachelineIndex=Integer.parseInt(eabin.substring(13,16),2);
            int tag=Integer.parseInt(eabin.substring(0,13),2);
            
            	if(tag==cache1.cacheline[CachelineIndex].getTag()){
            	
            		TextArea2.append("\nThe word is in block "+ effaddr +" in the memory");
            		TextArea2.append("\nThe word is the "+ memIndex +" number in the block ");
            		TextArea2.append("\nThe word can be found in cacheline "+ CachelineIndex);
            		//set present bit and write bit
            		
            		 //present bit = 1, which means there is valid data in the cacheline.
            		int p=1;
                    cache1.cacheline[CachelineIndex].setPresent(p);
                    TextArea2.append("\nSet the present bit = 1");
                    
                    //write bit = 1; which means word is modified.         
                    int w=1;
                    cache1.cacheline[CachelineIndex].setWrite(w);
                    TextArea2.append("\nSet the write bit = 1");
                    
                    if (reg == 00){
        				
          				 cache1.cacheline[CachelineIndex].setWord(r[0],memIndex);
          				 TextArea2.append("\nStore r[0]= "+r[0]
                  			+" to Word["+ memIndex+"] in cacheline" + CachelineIndex);
          				
          			 }
                    
                    if (reg == 01){
        				
          				 cache1.cacheline[CachelineIndex].setWord(r[1],memIndex);
          				 TextArea2.append("\nStore r[1]= "+r[1]
                  			+" to Word["+ memIndex+"] in cacheline" + CachelineIndex);
          				
          			 }
                    
                    if (reg == 10){
         				
          				 cache1.cacheline[CachelineIndex].setWord(r[2],memIndex);
          				 TextArea2.append("\nStore r[2]= "+r[2]
                  			+" to Word["+ memIndex+"] in cacheline" + CachelineIndex);
          				
          			 }
                    
                    if (reg == 11){
          				
          				 cache1.cacheline[CachelineIndex].setWord(r[3],memIndex);
          				 TextArea2.append("\nStore r[3]= "+r[3]
                  			+" to Word["+ memIndex+"] in cacheline" + CachelineIndex);
          				
          			 }
                    
            	}
            	
            	if(tag!=cache1.cacheline[CachelineIndex].getTag()){
                	
            		TextArea2.append("\nThe memory location is not in cache");
                	TextArea2.append("\nNo write allocate policy, write directly to memory without allocation");
                	
                	 if (reg == 00){
                		 memory[newEA]=r[0];
                		 TextArea2.append("\nwrite r[0]" +r[0] +" to memory["+ newEA+"]");
                	 }
                	 
                	 if (reg == 01){
                		 memory[newEA]=r[1];
                		 TextArea2.append("\nwrite r[1]" +r[1] +" to memory["+ newEA+"]");
                	 }
                	 
                	 if (reg == 10){
                		 memory[newEA]=r[2];
                		 TextArea2.append("\nwrite r[2]" +r[2] +" to memory["+ newEA+"]");
                	 }
                	 
                	 if (reg == 11){
                		 memory[newEA]=r[3];
                		 TextArea2.append("\nwrite r[3]" +r[3] +" to memory["+ newEA+"]");
                	 }
            		
            	}
            	
   			}
   			
   			if (newEA >2047){
   				TextArea2.append("\nThe indirect address number is larger than 2047");
                              
   			}
        
    
   		 }
     }

//LDA instruction    
    public void loadregadd(int reg,int ea) {
        String eabinary=Integer.toBinaryString(ea);
        if(reg==00)
        {
            TextArea2.append("\nLoading register R0 with address "+eabinary);
            r[0]=ea;
        }
        if(reg==01)
        {
            TextArea2.append("\nLoading register R1 with address "+eabinary);
            r[1]=ea;
        }
        if(reg==10)
        {   
            TextArea2.append("\nLoading register R2 with address "+eabinary);
            r[2]=ea;
        }
        if(reg==11)
        {
            TextArea2.append("\nLoading register R3 with address "+eabinary);
            r[3]=ea;
        }
    }

 //LDX instruction 
    public void loadindexreg(int ix,int ea,int ival) {
       
    	String eabinary=Integer.toBinaryString(ea);
    	TextArea2.append("\nLoad index register "+ix+" from memory instruction, the effective address is "+eabinary);
    
        int effaddr=ea/6;//effaddr equals to the number of block
        int memIndex=ea%6; //memIndex is the position of Word in a block
        String eabin=Integer.toBinaryString(effaddr);
         while (eabin.length() < 16) {
            eabin = "0" + eabin;
        }
        int CachelineIndex=Integer.parseInt(eabin.substring(13,16),2);
        int tag=Integer.parseInt(eabin.substring(0,13),2);
      
   //if the address can be found in cache  
        if(tag==cache1.cacheline[CachelineIndex].getTag()){
        	TextArea2.append("\nThe word is in block "+ effaddr +" in the memory");
        	TextArea2.append("\nThe word is the "+ memIndex +" number in the block ");
        	TextArea2.append("\nThe word can be found in cacheline "+ CachelineIndex);
    	
//present bit = 1, which means the number can be found in cache.
        	int p=1;
        	cache1.cacheline[CachelineIndex].setPresent(p);
        	TextArea2.append("\nSet the present bit = 1");
        
//write bit = 0; which means no word is modified.         
        	TextArea2.append("\nTAG bits remain the same");
        
//load the number from cacheline
        	if( ival == 0){//no indirect addressing in the instruction
        	
        	  if(ix==01)
              {
                  TextArea2.append("\nLoading Index register X1 from memory "+eabinary);
                  ixarray[0]=cache1.cacheline[CachelineIndex].getWord(memIndex);;
              }  
        	  if(ix==10)
              {
                  TextArea2.append("\nLoading Index register X2 from memory "+eabinary);
                  ixarray[1]=cache1.cacheline[CachelineIndex].getWord(memIndex);;
              }
        	  if(ix==11)
              {
                  TextArea2.append("\nLoading Index register X3 from memory "+eabinary);
                  ixarray[2]=cache1.cacheline[CachelineIndex].getWord(memIndex);;
              }  
        	}
        }else if(tag!=cache1.cacheline[CachelineIndex].getTag()){
        	 
       	 	 TextArea2.append("\nThe word is in block "+ effaddr +" in the memory");
        	 TextArea2.append("\nThe word is the "+ memIndex +" number in the block");
        	 TextArea2.append("\nThe word cannot be found in cacheline "+ CachelineIndex);
   //if  w == 1,  means the data in block have been modified,
   //write back the whole cacheline to memory.

       	 if( cache1.cacheline[CachelineIndex].getWrite()==1){
       		 
       		 TextArea2.append("\nIn cacheline "+ CachelineIndex+" the data have been modified");
       		 
       		 //Copy the present block in cacheline to block in memory
       		 //using write back strategy
       		 int startAddress= (cache1.cacheline[CachelineIndex].getTag() *  				
       				 cache1.cache_length + CachelineIndex)*       				 
       				 cache1.words_per_line;
       		 
       		 
       		 for(int iPara=0; iPara<cache1.words_per_line; iPara++){
       			 
       		 memory[startAddress+iPara]=cache1.cacheline[CachelineIndex].getWord(iPara);
       		 
       		 }
       		 
       		 int blockNumber = cache1.cacheline[CachelineIndex].getTag()*
       				 cache1.cache_length + CachelineIndex;
       		 
       		 TextArea2.append("\nCopy the cacheline "+ CachelineIndex +" to block" +
       				 blockNumber+" in memory");
       		 
       		 //Copy new block from memory
       		 int copyFromAddress= (tag *
       				 
       				 cache1.cache_length + CachelineIndex) * cache1.words_per_line;
       		 
       		 for(int iPara=0; iPara<cache1.words_per_line; iPara++){
       			 
           		 cache1.cacheline[CachelineIndex].setWord(memory[copyFromAddress+iPara],iPara);
           		 }
       		 
       		 int blockNumber2=tag * cache1.cache_length + CachelineIndex;
       		 TextArea2.append("\nLoad block "+ blockNumber2 +" from memory to cacheline" +
       				 CachelineIndex);
       		 
       		 //set TAG,present bit and write bit
       		 //tag is the integer derived from effective address;
       		 
       		 cache1.cacheline[CachelineIndex].setTag(tag);
       		 TextArea2.append("\nSet new TAG number " + tag);
       		 
       		//present bit = 1, which means the number can be found in cache.
       		 int p=1;
       		 cache1.cacheline[CachelineIndex].setPresent(p);
       		 TextArea2.append("\nSet present bit = 1");
       		 
       		//write bit = 0; which means no word is modified.         
       		 int w=0;
       		 cache1.cacheline[CachelineIndex].setWrite(w);
       		 TextArea2.append("\nSet write bit = 0");
       		 
       		 //load the number from cacheline
       		
       		 if( ival == 0){//no indirect addressing in the instruction
       		 if(ix==01)
                {
                    TextArea2.append("\nLoading Index register X1 from memory "+eabinary);
                    ixarray[0]=cache1.cacheline[CachelineIndex].getWord(memIndex);;
                }  
          	  if(ix==10)
                {
                    TextArea2.append("\nLoading Index register X2 from memory "+eabinary);
                    ixarray[1]=cache1.cacheline[CachelineIndex].getWord(memIndex);;
                }
          	  if(ix==11)
                {
                    TextArea2.append("\nLoading Index register X3 from memory "+eabinary);
                    ixarray[2]=cache1.cacheline[CachelineIndex].getWord(memIndex);;
                }  
        }
       
       	 }else if( cache1.cacheline[CachelineIndex].getWrite()==0){
       	//In this condition, no word is modified in the cacheline[index], so the only thing 
    		 //to do is to copy the corresponding block into cache.
    		 TextArea2.append("\nIn cacheline "+ CachelineIndex+" the data have not been modified");
    		 //Copy new block from memory
    		 int copyFromAddress= (tag *
    				 
    				 cache1.cache_length + CachelineIndex) * cache1.words_per_line;
    		 
    		 for(int iPara=0; iPara<cache1.words_per_line; iPara++){
    			 
        		 cache1.cacheline[CachelineIndex].setWord(memory[copyFromAddress+iPara],iPara);
        		 }
    		 int blockNumber3 = tag * cache1.cache_length + CachelineIndex;
    		 TextArea2.append("\nLoad block "+ blockNumber3 +" from memory to cacheline" +
    				 CachelineIndex);
    		 //set TAG,present bit and write bit
    		 //tag is the integer derived from effective address;
    		 
    		 cache1.cacheline[CachelineIndex].setTag(tag);
    		 TextArea2.append("\nSet new TAG number" + tag);
    		 
    		//present bit = 1
    		 int p=1;
    		 cache1.cacheline[CachelineIndex].setPresent(p);
    		 TextArea2.append("\nSet present bit = 1");
    		 
    		//write bit = 0; which means no word is modified.         
    		 int w=0;
    		 cache1.cacheline[CachelineIndex].setWrite(w);
    		 TextArea2.append("\nSet write bit = 0");
    		 
    		 //load the number from cacheline
             
             
           
    		 if( ival == 0){//no indirect addressing in the instruction
    			
           	  if(ix==01)
                 {
                     TextArea2.append("\nLoading Index register X1 from memory "+eabinary);
                     ixarray[0]=cache1.cacheline[CachelineIndex].getWord(memIndex);;
                 }  
           	  if(ix==10)
                 {
                     TextArea2.append("\nLoading Index register X2 from memory "+eabinary);
                     ixarray[1]=cache1.cacheline[CachelineIndex].getWord(memIndex);;
                 }
           	  if(ix==11)
                 {
                     TextArea2.append("\nLoading Index register X3 from memory "+eabinary);
                     ixarray[2]=cache1.cacheline[CachelineIndex].getWord(memIndex);;
                 }  
    		 }
       	 }
       	 
      }
   }
 
//STX instruction
    public void storeindexreg(int ix,int ea,int ival) {
     
    
        String eabinary=Integer.toBinaryString(ea);//write back policy
    	TextArea2.append("\nThe effective address in this store instruction is"+eabinary);
    	TextArea2.append("\nStore index eregister ["+ ix +"] to memory");
    	
    	if(ival==0) {
    		
    		TextArea2.append("\nNo indirect addressing...");
    		int effaddr=ea/6;//effaddr equals to the number of block
            int memIndex=ea%6; //memIndex is the position of Word in a block
            String eabin=Integer.toBinaryString(effaddr);
             while (eabin.length() < 16) {
            eabin = "0" + eabin;
        }
            int CachelineIndex=Integer.parseInt(eabin.substring(13,16),2);
            int tag=Integer.parseInt(eabin.substring(0,13),2);
            
            if(tag==cache1.cacheline[CachelineIndex].getTag()){
            	
            	TextArea2.append("\nThe word is in block "+ effaddr +" in the memory");
            	TextArea2.append("\nThe word is the "+ memIndex +" number in the block ");
            	TextArea2.append("\nThe word can be found in cacheline"+ CachelineIndex);
            	
            	 //present bit = 1, which means there is valid data in the cacheline.
            	 int p=1;
                 cache1.cacheline[CachelineIndex].setPresent(p);
                 TextArea2.append("\nSet the present bit = 1");
                 
                 //write bit = 1; which means word is modified.         
                 int w=1;
                 cache1.cacheline[CachelineIndex].setWrite(w);
                 TextArea2.append("\nSet the write bit = 1");
                 
                  
                 if(ix==01)
                 {
                     TextArea2.append("\nstore Index register X1 to memory "+eabinary);
                     cache1.cacheline[CachelineIndex].setWord(ixarray[0],memIndex);
                 }  
                 if(ix==10)
                 {
           		 TextArea2.append("\nstore Index register X2 to memory "+eabinary);
           		  cache1.cacheline[CachelineIndex].setWord(ixarray[1],memIndex);
                 }
                 if(ix==11)
                 {
           		  	 TextArea2.append("\nstore Index register X3 to memory "+eabinary);
           		  	 cache1.cacheline[CachelineIndex].setWord(ixarray[2],memIndex);
                 }  
            }
            
            if(tag!=cache1.cacheline[CachelineIndex].getTag()){
            	
            	TextArea2.append("\nThe memory location is not in cache");
            	TextArea2.append("\nNo write allocate policy, write directly to memory without allocation");
            	
                 if(ix==01)
                 {
                     TextArea2.append("\nstore Index register X1 to memory "+eabinary);
                     cache1.cacheline[CachelineIndex].setWord(ixarray[0],memIndex);
                 }  
                 if(ix==10)
                 {
           		  TextArea2.append("\nstore Index register X2 to memory "+eabinary);
           		  cache1.cacheline[CachelineIndex].setWord(ixarray[1],memIndex);
                 }
                 if(ix==11)
                 {
           		  	 TextArea2.append("\nstore Index register X3 to memory "+eabinary);
           		  	 cache1.cacheline[CachelineIndex].setWord(ixarray[2],memIndex);
                 }  
            	
            }
    	}
    
    
    }

    public void ipl(String instruction) {
           //String instruction=new String(TextArea.getText());               
           //Storing the user input instruction 
           if(instruction.length()>16)
           {
               TextArea2.append("\nInvalid instruction, more than 16 bits");
             //  msr = 2;
               TextArea2.append("\nIllegal Operation Code, machine fault: 1");
               MFRTextField.setText("1");
              }
              
           int reg=Integer.valueOf(instruction.substring(6,8));             //string from 6 to 7 denotes register, converting it to integer
           int ix=Integer.valueOf(instruction.substring(8,10));             //string from 8 to 9 denotes IX
           int ival=Integer.valueOf(instruction.substring(10,11));                //Character at position 10 denotes I value
           String binaryaddress =instruction.substring(11,16);              
           int address=Integer.valueOf(instruction.substring(11,16));
           int decaddress=Integer.parseInt(instruction.substring(11, 16),2);
           int ixdec=Integer.parseInt(instruction.substring(8, 10),2);
           OPCODETextfield.setText(instruction.substring(0,6));             //Setting Opcode textfield to opcode found in input
           IXTextfield.setText(instruction.substring(8,10));                //Setting IX textfield to IX from input instruction    
           ITextField.setText(""+instruction.charAt(10));                   //setting I to I value from input instruction
           AddressTextfield.setText(instruction.substring(11,16));          //Setting address text field to address from input instruction
           
           if(decaddress>32)
           { 
               MFRTextField.setText("3, illegal memory address");
           }
           
           
           if(reg==00)                                                      //Selecting the radio button of the register used in the instruction
               R0RadioButton.setSelected(true);
           if(reg==01)
               R0RadioButton.setSelected(true);
           if(reg==10)
               R0RadioButton.setSelected(true);
           if(reg==11)
               R0RadioButton.setSelected(true);
           int opdec=Integer.parseInt(instruction.substring(0,6),2);
        
           int ea=effectiveaddress(ival,ixdec,decaddress);       //calling effective address funtion to calculate and return EA   
          
           if(opdec==1)
               loadregister(reg,ea,ival);                                   //LDR instruction function call
           if(opdec==2)
               storeregister(reg,ea,ival);                                       //STR instruciton function call
           if(opdec==3)
               loadregadd(reg,ea);                                          //LDA instruction function call
           if(opdec==41)
               loadindexreg(ix,ea,ival);                                         //LDX instruction funciton call
           if(opdec==42)    
               storeindexreg(ix,ea,ival);                                        //STX instruction function call
          // if(opdec !=1 && opdec !=2 && opdec !=3 && opdec !=41 && opdec !=42)
            //   TextArea.append("\nNo such opcode found....");
           if(opdec==0)
               TextArea2.append("\nHALT - Machine is stopped");  
           
           /*Traps to memory address 0, which contains the address of a table in memory.
           *Stores the PC+1 in memory location 2.
           *The table can have a maximum of 16 entries representing 16 routines for user-specified
           *instructions stored elsewhere in memory. 
           *Trap code contains an index into the table,
           *e.g. it takes values 0 – 15. When a TRAP instruction is executed,
           *it goes to the routine whose address is in memory location 0,
           *executes those instructions, and returns to the instruction 
           *stored in memory location 2. The PC+1 of the TRAP instruction is stored in memory location 2.
            */
            if(opdec==36){
               int trapCode=Integer.parseInt(instruction.substring(11,15),2);
               trapInstr(trapCode);
           }
        
           
    }
    private void trapInstr(int trapCode){
        
        TextArea2.append("\nTRAP - Trap to memory[0]:" + memory[0]);
        TextArea2.append("\nThe trap code is" + trapCode); 
        TextArea2.append("\nThe address of the trap program starts from "
                + "\nmemory[memory[0] + trapcode]:" + memory[memory[0]+trapCode]);  
        TextArea2.append("\nThe trap program is executing..."); 
  
        TextArea2.append("\n PC + 1 = memory[2] = " + memory[2]);  
        
    }
    
    //Jump if zero instruction
    private void jumpifzero(int reg, int pc, int ea) 
    {
        TextArea2.append("Jump if zero instruction \n");
        if(reg==00)
        {
         if(r[0]==0)
         {
             pc=ea;
         }
         else
             pc++;
        }
        if(reg==01)
        {
         if(r[1]==0)
         {
             pc=ea;
         }
         else
             pc++;
        }
        if(reg==10)
        {
         if(r[2]==0)
         {
             pc=ea;
         }
         else
             pc++;
        }
        if(reg==11)
        {
         if(r[3]==0)
         {
             pc=ea;
         }
         else
             pc++;
        }
    }

    //Jump if not equal
    private void jumpifnotequal(int reg, int pc, int ea) 
    {
        TextArea2.append("Jump if not equal instruction \n");
        if(reg==00)
        {
         if(r[0]!=0)
         {
             pc=ea;
         }
         else
             pc++;
        }
        if(reg==01)
        {
         if(r[1]!=0)
         {
             pc=ea;
         }
         else
             pc++;
        }
        if(reg==10)
        {
         if(r[2]!=0)
         {
             pc=ea;
         }
         else
             pc++;
        }
        if(reg==11)
        {
         if(r[3]!=0)
         {
             pc=ea;
         }
         else
             pc++;
        }       
    }

    //Jump if condition code
    private void jumpifcondcode(int[] cc, int pc, int ea) 
    {
        TextArea2.append("Jump if condtion code instruction \n");
        if(cc[0]==1)
        {
            pc=ea;
        }
        else
            pc++;
    }

    //Uncoditional jump
    private void uncondjump(int pc, int ea) 
    {
       TextArea2.append("Unconditional jump to address instruction\n"); 
       pc=ea;
       PCTextfield.setText(Integer.toString(pc));
    }

    //Jump and save return address
    private void jumpsavereturnadd(int pc, int ea) 
    {
        TextArea2.append("Jump and save return address instruction \n");
        if(r[3]==0)
            pc++;
        else
            pc=ea;
        PCTextfield.setText(Integer.toString(pc));
    }

    //Subtract one and branch
    private void subtractbranch(int reg, int pc, int ea) 
    {
        TextArea2.append("Subtract one and branch instruction \n");
        if(reg==00)
        {
         r[0]=r[0]-1;
         if(r[0]>0)
             pc=ea;
         else
             pc++;
        }
        if(reg==01)
        {
         r[1]=r[1]-1;
         if(r[1]>0)
             pc=ea;
         else
             pc++;
        }
        if(reg==10)
        {
         r[2]=r[2]-1;
         if(r[2]>0)
             pc=ea;
         else
             pc++;
        }
        if(reg==11)
        {
         r[3]=r[3]-1;
         if(r[3]>0)
             pc=ea;
         else
             pc++;
        }        
        PCTextfield.setText(Integer.toString(pc));
    }

    //Jump greater than or equal to
    private void jumpgreater(int reg, int pc, int ea) 
    {
        TextArea2.append("Jump greater than or equal to instruction \n");
        if(reg==00)
        {
         if(r[0]>=0)
             pc=ea;
         else
             pc++;
        }
        if(reg==01)
        {
         if(r[1]>=0)
             pc=ea;
         else
             pc++;
        }
        if(reg==10)
        {
         if(r[2]>=0)
             pc=ea;
         else
             pc++;
        }
        if(reg==11)
        {
         if(r[3]>=0)
             pc=ea;
         else
             pc++;
        }       
        PCTextfield.setText(Integer.toString(pc));
    }

    //Return from subroutine
    private void returnsubroutine(int immediate) 
    {
        TextArea2.append("Return from subroutine instruction \n");       
        r[0]=immediate;
        pc=r[3];
        PCTextfield.setText(Integer.toString(pc));
    }

   
    //add memory to register
    private void addmemtoreg(int reg, int ea,int ival) 
    {
String eabinary=Integer.toBinaryString(ea);
    	TextArea2.append("\nAdd memory to register instruction,  the effective address is "+eabinary);
        int effaddr=ea/6;//effaddr equals to the number of block
        int memIndex=ea%6; //memIndex is the position of Word in a block
        String eabin=Integer.toBinaryString(effaddr);
        while (eabin.length() < 16) {
            eabin = "0" + eabin;
        }
        int CachelineIndex=Integer.parseInt(eabin.substring(13,16),2);
        int tag=Integer.parseInt(eabin.substring(0,13),2);
      
   //if the address can be found in cache  
        if(tag==cache1.cacheline[CachelineIndex].getTag()){
        	
        	TextArea2.append("\nThe word is in block "+ effaddr +" in the memory");
        	TextArea2.append("\nThe word is the "+ memIndex +" number in the block ");
        	TextArea2.append("\nThe word can be found in cacheline "+ CachelineIndex);
        	
   //present bit = 1, which means the number can be found in cache.
            int p=1;
            cache1.cacheline[CachelineIndex].setPresent(p);
            TextArea2.append("\nSet the present bit = 1");
            
   //write bit = 0; which means no word is modified.         
            int w=0;
            cache1.cacheline[CachelineIndex].setWrite(w);
            TextArea2.append("\nSet the write bit = 0");
            TextArea2.append("\nTAG bits remain the same");
            
   //load the number from cacheline
            if( ival == 0){//no indirect addressing in the instruction
   			 
   			 
   			 if (reg == 00){
                             int n=r[0];
   				 TextArea2.append("\nNo indirect addressing...");
   				 r[0]=cache1.cacheline[CachelineIndex].getWord(memIndex)+r[0];
   				 TextArea2.append("\nr[0]="+n+"+"+memory[ea]+"="+r[0]);
   				 R0Textfield.setText(""+r[0]);
   			 }
   			 
            
   			 if (reg == 01){
                                int n = r[1];
                                 TextArea2.append("\nNo indirect addressing...");
   				 r[1]=cache1.cacheline[CachelineIndex].getWord(memIndex)+r[1];
                                 TextArea2.append("\nr[1]="+n+"+"+memory[ea]+"="+r[1]);
   				 R1TextField.setText(""+r[1]);
   			 }
   			 
            
   			 if (reg == 10){
                                int n = r[2];
                             TextArea2.append("\nNo indirect addressing...");
   				 r[2]=cache1.cacheline[CachelineIndex].getWord(memIndex)+r[2];
                                 TextArea2.append("\nr[2]="+n+"+"+memory[ea]+"="+r[2]);
   				 R2Textfield.setText(""+r[2]);
   				 
   			 }
   			 
   			 
   			 if (reg == 11){
                                int n = r[3];
                             TextArea2.append("\nNo indirect addressing...");
   				 r[3]=cache1.cacheline[CachelineIndex].getWord(memIndex)+r[3];
                                 TextArea2.append("\nr[3]="+n+"+"+memory[ea]+"="+r[3]);
   				 R3Textfield.setText(""+r[3]);
   			 }
   			 
   			 
   		 }
        }
        else if(tag!=cache1.cacheline[CachelineIndex].getTag()){
   			 
   		 
   			 TextArea2.append("\nThe word is in block "+ effaddr +" in the memory");
         	 TextArea2.append("\nThe word is the "+ memIndex +" number in the block");
         	 TextArea2.append("\nThe word cannot be found in cacheline "+ CachelineIndex);
    //if  w == 1,  means the data in block have been modified,
    //write back the whole cacheline to memory.
 
        	 if( cache1.cacheline[CachelineIndex].getWrite()==1){
        		 
        		 TextArea2.append("\nIn cacheline "+ CachelineIndex+" the data have been modified");
        		 
        		 //Copy the present block in cacheline to block in memory
        		 //using write back strategy
        		 int startAddress= (cache1.cacheline[CachelineIndex].getTag() * 
        				
        				 cache1.cache_length + CachelineIndex)*
        				 
        				 cache1.words_per_line;
        		 
        		 
        		 for(int iPara=0; iPara<cache1.words_per_line; iPara++){
        			 
        		 memory[startAddress+iPara]=cache1.cacheline[CachelineIndex].getWord(iPara);
        		 
        		 }
        		 
        		 int blockNumber = cache1.cacheline[CachelineIndex].getTag()*
        				 cache1.cache_length + CachelineIndex;
        		 
        		 TextArea2.append("\nCopy the cacheline "+ CachelineIndex +" to block" +
        				 blockNumber+" in memory");
        		 
        		 //Copy new block from memory
        		 int copyFromAddress= (tag *
        				 
        				 cache1.cache_length + CachelineIndex) * cache1.words_per_line;
        		 
        		 for(int iPara=0; iPara<cache1.words_per_line; iPara++){
        			 
            		 cache1.cacheline[CachelineIndex].setWord(memory[copyFromAddress+iPara],iPara);
            		 }
        		 
        		 int blockNumber2=tag * cache1.cache_length + CachelineIndex;
        		 TextArea2.append("\nLoad block "+ blockNumber2 +" from memory to cacheline" +
        				 CachelineIndex);
        		 
        		 //set TAG,present bit and write bit
        		 //tag is the integer derived from effective address;
        		 
        		 cache1.cacheline[CachelineIndex].setTag(tag);
        		 TextArea2.append("\nSet new TAG number" + tag);
        		 
        		//present bit = 1, which means the number can be found in cache.
        		 cache1.cacheline[CachelineIndex].setPresent(1);
        		 TextArea2.append("\nSet present bit = 1");
        		 
        		//write bit = 0; which means no word is modified.         
        		 cache1.cacheline[CachelineIndex].setWrite(0);
        		 TextArea2.append("\nSet write bit = 0");
        		 
        		 //load the number from cacheline
        		
        		 if( ival == 0){//no indirect addressing in the instruction
        				 
   			 
   			 if (reg == 00){
                             int n=r[0];
   				 TextArea2.append("\nNo indirect addressing...");
   				 r[0]=cache1.cacheline[CachelineIndex].getWord(memIndex)+r[0];
   				 TextArea2.append("\nr[0]="+n+"+"+memory[ea]+"="+r[0]);
   				 R0Textfield.setText(""+r[0]);
                                 
   			 }
   			 
            
   			 if (reg == 01){
                                int n = r[1];
                                 TextArea2.append("\nNo indirect addressing...");
   				 r[1]=cache1.cacheline[CachelineIndex].getWord(memIndex)+r[1];
                                 TextArea2.append("\nr[1]="+n+"+"+memory[ea]+"="+r[1]);
   				 R1TextField.setText(""+r[1]);
   			 }
   			 
            
   			 if (reg == 10){
                                int n = r[2];
                             TextArea2.append("\nNo indirect addressing...");
   				 r[2]=cache1.cacheline[CachelineIndex].getWord(memIndex)+r[2];
                                 TextArea2.append("\nr[2]="+n+"+"+memory[ea]+"="+r[2]);
   				 R2Textfield.setText(""+r[2]);
   				 
   			 }
   			 
   			 
   			 if (reg == 11){
                                int n = r[3];
                             TextArea2.append("\nNo indirect addressing...");
   				 r[3]=cache1.cacheline[CachelineIndex].getWord(memIndex)+r[3];
                                 TextArea2.append("\nr[3]="+n+"+"+memory[ea]+"="+r[3]);
   				 R3Textfield.setText(""+r[3]);
   			 }

   			 
                         }
        	 }
                else if(cache1.cacheline[CachelineIndex].getWrite()==0){
        		 //In this condition, no word is modified in the cacheline[index], so the only thing 
        		 //to do is to copy the corresponding block into cache.
        		 TextArea2.append("\nIn cacheline "+ CachelineIndex+" the data have not been modified");
        		 //Copy new block from memory
        		 int copyFromAddress= (tag *cache1.cache_length + CachelineIndex) * cache1.words_per_line;
        		 
        		 for(int iPara=0; iPara<cache1.words_per_line; iPara++){
        			 
            		 cache1.cacheline[CachelineIndex].setWord(memory[copyFromAddress+iPara],iPara);
            		 }
        		 int blockNumber3 = tag * cache1.cache_length + CachelineIndex;
        		 TextArea2.append("\nLoad block "+ blockNumber3 +" from memory to cacheline" +
        				 CachelineIndex);
        		 //set TAG,present bit and write bit
        		 //tag is the integer derived from effective address;
        		 
        		 cache1.cacheline[CachelineIndex].setTag(tag);
        		 TextArea2.append("\nSet new TAG number:" + tag);
        		 
        		//present bit = 1
        		 cache1.cacheline[CachelineIndex].setPresent(1);
        		 TextArea2.append("\nSet present bit = 1");
        		 
        		//write bit = 0; which means no word is modified.         
        		 cache1.cacheline[CachelineIndex].setWrite(0);
        		 TextArea2.append("\nSet write bit = 0");
        		 
        		 //load the number from cacheline
                 	 if( ival == 0){//no indirect addressing in the instruction
        		 if (reg == 00){
                             int n=r[0];
   				 TextArea2.append("\nNo indirect addressing...");
   				 r[0]=cache1.cacheline[CachelineIndex].getWord(memIndex)+r[0];
   				 TextArea2.append("\nr[0]="+n+"+"+memory[ea]+"="+r[0]);
   				 R0Textfield.setText(""+r[0]);
   			 }
   			 
            
   			 if (reg == 01){
                                int n = r[1];
                                 TextArea2.append("\nNo indirect addressing...");
   				 r[1]=cache1.cacheline[CachelineIndex].getWord(memIndex)+r[1];
                                 TextArea2.append("\nr[1]="+n+"+"+memory[ea]+"="+r[1]);
   				 R1TextField.setText(""+r[1]);
   			 }
   			 
            
   			 if (reg == 10){
                                int n = r[2];
                             TextArea2.append("\nNo indirect addressing...");
   				 r[2]=cache1.cacheline[CachelineIndex].getWord(memIndex)+r[2];
                                 TextArea2.append("\nr[2]="+n+"+"+memory[ea]+"="+r[2]);
   				 R2Textfield.setText(""+r[2]);
   				 
   			 }
   			 
   			 
   			 if (reg == 11){
                                int n = r[3];
                             TextArea2.append("\nNo indirect addressing...");
   				 r[3]=cache1.cacheline[CachelineIndex].getWord(memIndex)+r[3];
                                 TextArea2.append("\nr[3]="+n+"+"+memory[ea]+"="+r[3]);
   				 R3Textfield.setText(""+r[3]);
   			 }
   			 
        		 }
        	 }
        }
        if(r[rr]==0)
            MSRTextField.setText("Z");
        if(r[rr]<0)
            MSRTextField.setText("N");
    }
    //Subtract memory from register
    private int submemfromreg(int reg, int ea, int ival) 
    {
     	String eabinary=Integer.toBinaryString(ea);
    	TextArea2.append("\nSubtract memory to register instruction,  the effective address is "+eabinary);
    
        int effaddr=ea/6;//effaddr equals to the number of block
        int memIndex=ea%6; //memIndex is the position of Word in a block
        String eabin=Integer.toBinaryString(effaddr);
         while (eabin.length() < 16) {
            eabin = "0" + eabin;
        }
        int CachelineIndex=Integer.parseInt(eabin.substring(13,16),2);
        int tag=Integer.parseInt(eabin.substring(0,13),2);
      
   //if the address can be found in cache  
        if(tag==cache1.cacheline[CachelineIndex].getTag()){
        	
        	TextArea2.append("\nThe word is in block "+ effaddr +" in the memory");
        	TextArea2.append("\nThe word is the "+ memIndex +" number in the block ");
        	TextArea2.append("\nThe word can be found in cacheline "+ CachelineIndex);
        	
   //present bit = 1, which means the number can be found in cache.
            int p=1;
            cache1.cacheline[CachelineIndex].setPresent(p);
            TextArea2.append("\nSet the present bit = 1");
            
   //write bit = 0; which means no word is modified.         
            int w=0;
            cache1.cacheline[CachelineIndex].setWrite(w);
            TextArea2.append("\nSet the write bit = 0");
            TextArea2.append("\nTAG bits remain the same");
            
   //load the number from cacheline
            if( ival == 0){//no indirect addressing in the instruction
   			 
   			 
   			 if (reg == 00){
   				 TextArea2.append("\nNo indirect addressing...");
   				 r[0]=r[0]-memory[ea];
   				 TextArea2.append("\nr[0]=c(r)-c(EA)= "+r[0]);
   				 R0Textfield.setText(""+r[0]);
   				 return r[0];
   			 }
   			 
            
   			 if (reg == 01){
   				 TextArea2.append("\nNo indirect addressing...");
   				 r[1]=r[1]-memory[ea];
   				 TextArea2.append("\nr[1]=c(r)-c(EA)= "+r[1]);
   				 R1TextField.setText(""+r[1]);
   				 return r[1];
   			 }
   			 
            
   			 if (reg == 10){
   				 TextArea2.append("\nNo indirect addressing...");
   				 r[2]=r[2]-memory[ea];
   				 TextArea2.append("\nr[2]=c(r)-c(EA)= "+r[2]);
   				 TextArea2.append("\nr[2] "+r[2]);
   				 TextArea2.append("\nc[ea] "+memory[ea]);
   				 R2Textfield.setText(""+r[2]);
   				 return r[2];
   				 
   			 }
   			 
   			 
   			 if (reg == 11){
   				 TextArea2.append("\nNo indirect addressing...");
   				 r[3]=r[3]-memory[ea];
   				 TextArea2.append("\nr[3]=c(r)-c(EA)= "+r[3]);
   				 R3Textfield.setText(""+r[3]);
   				 return r[3];
   			 }
            }
        }else if(tag!=cache1.cacheline[CachelineIndex].getTag()){
   			 
   		 
   			 TextArea2.append("\nThe word is in block"+ effaddr +"in the memory");
         	 TextArea2.append("\nThe word is the"+ memIndex +"number in the block");
         	 TextArea2.append("\nThe word cannot be found in cacheline"+ CachelineIndex);
         	 
    //if  w == 1,  means the data in block have been modified,
    //write back the whole cacheline to memory.
 
        	 if( cache1.cacheline[CachelineIndex].getWrite()==1){
        		 
        		 TextArea2.append("\nIn cacheline"+ CachelineIndex+" the data have been modified");
        		 
        		 //Copy the present block in cacheline to block in memory
        		 //using write back strategy
        		 int startAddress= (cache1.cacheline[CachelineIndex].getTag() * 
        				
        				 cache1.cache_length + CachelineIndex)*
        				 
        				 cache1.words_per_line;
        		 
        		 
        		 for(int iPara=0; iPara<cache1.words_per_line; iPara++){
        			 
        		 memory[startAddress+iPara]=cache1.cacheline[CachelineIndex].getWord(iPara);
        		 
        		 }
        		 
        		 int blockNumber = cache1.cacheline[CachelineIndex].getTag()*
        				 cache1.cache_length + CachelineIndex;
        		 
        		 TextArea2.append("\nCopy the cacheline"+ CachelineIndex +" to block" +
        				 blockNumber+" in memory");
        		 
        		 //Copy new block from memory
        		 int copyFromAddress= (tag *
        				 
        				 cache1.cache_length + CachelineIndex) * cache1.words_per_line;
        		 
        		 for(int iPara=0; iPara<cache1.words_per_line; iPara++){
        			 
            		 cache1.cacheline[CachelineIndex].setWord(memory[copyFromAddress+iPara],iPara);
            		 }
        		 
        		 int blockNumber2=tag * cache1.cache_length + CachelineIndex;
        		 TextArea2.append("\nLoad block "+ blockNumber2 +" from memory to cacheline" +
        				 CachelineIndex);
        		 
        		 //set TAG,present bit and write bit
        		 //tag is the integer derived from effective address;
        		 
        		 cache1.cacheline[CachelineIndex].setTag(tag);
        		 TextArea2.append("\nSet new TAG number" + tag);
        		 
        		//present bit = 1, which means the number can be found in cache.
        		 cache1.cacheline[CachelineIndex].setPresent(1);
        		 TextArea2.append("\nSet present bit = 1");
        		 
        		//write bit = 0; which means no word is modified.         
        		 cache1.cacheline[CachelineIndex].setWrite(0);
        		 TextArea2.append("\nSet write bit = 0");
        		 
        		 //load the number from cacheline
        		
        		 if( ival == 0){//no indirect addressing in the instruction
        			 
        			 
        			 if (reg == 00){
        				 TextArea2.append("\nNo indirect addressing...");
           				 r[0]=-cache1.cacheline[CachelineIndex].getWord(memIndex)+r[0];
           				 TextArea2.append("\nr[0]=c(r)-c(EA)= "+r[0]);
           				 R0Textfield.setText(""+r[0]);
           				 return r[0];
        			 }
        			 
                 
        			 if (reg == 01){
        				 TextArea2.append("\nNo indirect addressing...");
           				 r[1]=-cache1.cacheline[CachelineIndex].getWord(memIndex)+r[1];
           				 TextArea2.append("\nr[1]=c(r)-c(EA)= "+r[1]);
           				 R1TextField.setText(""+r[1]);
           				 return r[1];
        			 }
        			 
                 
        			 if (reg == 10){
        				 TextArea2.append("\nNo indirect addressing...");
           				 r[2]=-cache1.cacheline[CachelineIndex].getWord(memIndex)+r[2];
           				 TextArea2.append("\nr[2]=c(r)-c(EA)= "+r[2]);
           				 R2Textfield.setText(""+r[2]);
           				 return r[2];
        			 }
        			 
        			 
        			 if (reg == 11){
        				 TextArea2.append("\nNo indirect addressing...");
           				 r[3]=-cache1.cacheline[CachelineIndex].getWord(memIndex)+r[3];
           				 TextArea2.append("\nr[3]=c(r)-c(EA)= "+r[3]);
           				 R3Textfield.setText(""+r[3]);
           				 return r[3];
        			 }
        			 
        			 
        		 }
        	 }else if(cache1.cacheline[CachelineIndex].getWrite()==0){
        		 //In this condition, no word is modified in the cacheline[index], so the only thing 
        		 //to do is to copy the corresponding block into cache.
        		 TextArea2.append("\nIn cacheline "+ CachelineIndex+" the data have not been modified");
        		 //Copy new block from memory
        		 int copyFromAddress= (tag *
        				 
        				 cache1.cache_length + CachelineIndex) * cache1.words_per_line;
        		 
        		 for(int iPara=0; iPara<cache1.words_per_line; iPara++){
        			 
            		 cache1.cacheline[CachelineIndex].setWord(memory[copyFromAddress+iPara],iPara);
            		 }
        		 int blockNumber3 = tag * cache1.cache_length + CachelineIndex;
        		 TextArea2.append("\nLoad block "+ blockNumber3 +" from memory to cacheline" +
        				 CachelineIndex);
        		 //set TAG,present bit and write bit
        		 //tag is the integer derived from effective address;
        		 
        		 cache1.cacheline[CachelineIndex].setTag(tag);
        		 TextArea2.append("\nSet new TAG number" + tag);
        		 
        		//present bit = 1
        		 cache1.cacheline[CachelineIndex].setPresent(1);
        		 TextArea2.append("\nSet present bit = 1");
        		 
        		//write bit = 0; which means no word is modified.         
        		 cache1.cacheline[CachelineIndex].setWrite(0);
        		 TextArea2.append("\nSet write bit = 0");
        		 
        		 //load the number from cacheline
                 
                 
               
        		 if( ival == 0){//no indirect addressing in the instruction
        			 
        			 
        			 if (reg == 00){
        				 TextArea2.append("\nNo indirect addressing...");
           				 r[0]=-cache1.cacheline[CachelineIndex].getWord(memIndex)+r[0];
           				 TextArea2.append("\nr[0]=c(r)-c(EA)= "+r[0]);
           				 R0Textfield.setText(""+r[0]);
           				 return r[1];
        			 }
        			 
                 
        			 if (reg == 01){
        				 TextArea2.append("\nNo indirect addressing...");
           				 r[1]=-cache1.cacheline[CachelineIndex].getWord(memIndex)+r[1];
           				 TextArea2.append("\nr[1]=c(r)-c(EA)= "+r[1]);
           				 R1TextField.setText(""+r[1]);
           				 return r[1];
        			 }
        			 
                 
        			 if (reg == 10){
        				 TextArea2.append("\nNo indirect addressing...");
           				 r[2]=-cache1.cacheline[CachelineIndex].getWord(memIndex)+r[2];
           				 TextArea2.append("\nr[2]=c(r)-c(EA)= "+r[2]);
           				 R2Textfield.setText(""+r[2]);
           				 return r[2];
        			 }
        			 
        			 
        			 if (reg == 11){
        				 TextArea2.append("\nNo indirect addressing...");
           				 r[3]=-cache1.cacheline[CachelineIndex].getWord(memIndex)+r[3];
           				 TextArea2.append("\nr[3]=c(r)-c(EA)= "+r[3]);
           				 R3Textfield.setText(""+r[3]);
           				 return r[3];
        			 }
        			 
        			 
        		 }
        	 }
        }
                if(r[rr]==0)
            MSRTextField.setText("Z");
        if(r[rr]<0)
            MSRTextField.setText("N");
                return -1;
      }
    

    //add immediate to register
    private void addimmtoreg(int reg, int immediate) 
    {
    if(reg==00)
      {
          r[0]=r[0]+immediate;
          TextArea2.append("Adding immediate to register R0\n");
      }
      if(reg==01)
      {
          r[1]=r[1]+immediate;
          TextArea2.append("Adding immediate to register R1\n");
      }
      if(reg==10)
      {
          r[2]=r[2]+immediate;
          TextArea2.append("Adding immediate to register R2\n");
      }   
      if(reg==11)
      {
          r[3]=r[3]+immediate;
          TextArea2.append("Adding immediate to register R3\n");
      }
              if(r[rr]==0)
            MSRTextField.setText("Z");
    }

    //Subtract immediate from register
    private void subimmtoreg(int reg, int immediate) 
    {
      if(reg==00)
      {
          r[0]=r[0]-immediate;
          TextArea2.append("Subtracting immediate from register R0\n");
      }
      if(reg==01)
      {
          r[1]=r[1]-immediate;
          TextArea2.append("Subtracting immediate from register R1\n");
      }
      if(reg==10)
      {
          r[2]=r[2]-immediate;
          TextArea2.append("Subtracting immediate from register R2\n");
      }   
      if(reg==11)
      {
          r[3]=r[3]-immediate;
          TextArea2.append("Subtracting immediate from register R3\n");
      }
              if(r[rr]==0)
            MSRTextField.setText("Z");
                      if(r[rr]<0)
            MSRTextField.setText("N");
    }
    
     //multiply registers
    private void multiplyregister(int x, int y, int rx) 
    {
        int result=x*y;
        String res=Integer.toBinaryString(result);
        while(res.length()<16)
        {
            res='0'+res;
        }
        r[rx]=Integer.parseInt(res.substring(0, 8),2);
        r[rx+1]=Integer.parseInt(res.substring(8, 16),2);
        TextArea2.append("\nCheck Register textfields for result...");
        if(rx==0)
        {
            R0Textfield.setText(Integer.toString(r[rx]));
            R1TextField.setText(Integer.toString(r[rx+1]));
        }

        if(rx==1)
        {
            R1TextField.setText(Integer.toString(r[rx]));
            R2Textfield.setText(Integer.toString(r[rx+1]));
        }

        if(rx==2)
        {
            R2Textfield.setText(Integer.toString(r[rx]));
            R3Textfield.setText(Integer.toString(r[rx+1]));
        }
        if(r[rr]==0)
            MSRTextField.setText("Z");
            if(r[rr]<0)
            MSRTextField.setText("N");
    }
    

    //divide register by register
    private void divideregister(int x, int y, int rx) {
        if(y==0)
        {
            cc[3]=1;
            CCTextfield.setText("DIV ZERO");
        }
        else
        {
        r[rx]=x/y;
        r[rx+1]=x%y;
        }
       TextArea2.append("\nCheck Register textfields for result...");
       if(rx==0)
        {
            R0Textfield.setText(Integer.toString(r[rx]));
            R1TextField.setText(Integer.toString(r[rx+1]));
        }

        if(rx==1)
        {
            R1TextField.setText(Integer.toString(r[rx]));
            R2Textfield.setText(Integer.toString(r[rx+1]));
        }

        if(rx==2)
        {
            R2Textfield.setText(Integer.toString(r[rx]));
            R3Textfield.setText(Integer.toString(r[rx+1]));
        }
        if(r[rr]==0)
            MSRTextField.setText("Z");
                if(r[rr]<0)
            MSRTextField.setText("N");
    }

    //Shift register by count
    private void shiftregister(int A_L, int L_R, int count, int reg) 
    {
        TextArea2.append("\nCheck Register textfields for result...");

        if(A_L==1) //logical shift ">>>" "<<<"
        {
            if(L_R==1) //left shift
            {
                if(reg==00)
                {
                    r[0]=r[0]<<count;
                    R0Textfield.setText(Integer.toString(r[0]));
                }
                if(reg==01)
                {
                    r[1]=r[1]<<count;
                    R1TextField.setText(Integer.toString(r[1]));
                }
                if(reg==10)
                {
                    r[2]=r[2]<<count;
                    R2Textfield.setText(Integer.toString(r[2]));
                }
                if(reg==11)
                {
                    r[3]=r[3]<<count;
                    R3Textfield.setText(Integer.toString(r[3]));                
                }
            }
            else    //right shift
            {
                if(reg==00)
                {
                    r[0]=r[0]>>>count;
                    R0Textfield.setText(Integer.toString(r[0]));
                }
                if(reg==01)
                {
                    r[1]=r[1]>>>count;
                    R1TextField.setText(Integer.toString(r[1]));
                }
                if(reg==10)
                {
                    r[2]=r[2]>>>count;
                    R2Textfield.setText(Integer.toString(r[2]));
                }
                 if(reg==11)
                {
                     r[3]=r[3]>>>count;
                     R3Textfield.setText(Integer.toString(r[3])); 
                }
                
            }
        }
        else    //arithmetical shift ">>" "<<"
        {
            if(L_R==1) //left shift
            {
                if(reg==00)
                {
                    r[0]=r[0]<<count;
                    R0Textfield.setText(Integer.toString(r[0]));
                }
                if(reg==01)
                {
                    r[1]=r[1]<<count;
                    R1TextField.setText(Integer.toString(r[1]));
                }
                if(reg==10)
                {
                    r[2]=r[2]<<count;
                    R2Textfield.setText(Integer.toString(r[2]));
                }
                if(reg==11)
                {
                    r[3]=r[3]<<count;
                    R3Textfield.setText(Integer.toString(r[3]));
                }
                
            }
            else    //right shift
            {
                if(reg==00)
                {
                    r[0]=r[0]>>count;
                    R0Textfield.setText(Integer.toString(r[0]));
                }
                if(reg==01)
                {
                    r[1]=r[1]>>count;
                    R1TextField.setText(Integer.toString(r[1]));
                }
                if(reg==10)
                {
                    r[2]=r[2]>>count;
                    R2Textfield.setText(Integer.toString(r[2]));
                }
                 if(reg==11)
                 {
                    r[3]=r[3]>>count;
                    R3Textfield.setText(Integer.toString(r[3]));
                 }               
            }            
        }
    
    }

    //Rotate register by count
    private void rotateregister(int A_L, int L_R, int count, int reg) 
    {
    TextArea2.append("\nSuccessfully rotated..");
    TextArea2.append("\nCheck Register textfields for result...");

    if(A_L==1) //logical rotate
        {
            if(L_R==1) //left rotate
            {
                if(reg==00)
                {
                    r[0]=Integer.rotateLeft(r[0],count);
                    R0Textfield.setText(Integer.toString(r[0]));
                }
                if(reg==01)
                {
                    r[1]=Integer.rotateLeft(r[1],count);
                    R1TextField.setText(Integer.toString(r[1]));
                }
                if(reg==10)
                {
                    r[2]=Integer.rotateLeft(r[2],count);
                     R2Textfield.setText(Integer.toString(r[2]));
                }
                if(reg==11)
                {
                    r[3]=Integer.rotateLeft(r[3],count);
                    R3Textfield.setText(Integer.toString(r[3]));
                }
            }
            else    //right rotate
            {
                if(reg==00)
                {
                    r[0]=Integer.rotateRight(r[0],count);
                    R0Textfield.setText(Integer.toString(r[0]));
                }
                if(reg==01)
                {
                    r[1]=Integer.rotateRight(r[1],count);
                    R1TextField.setText(Integer.toString(r[1]));
                }
                if(reg==10)
                {
                    r[2]=Integer.rotateRight(r[2],count);
                     R2Textfield.setText(Integer.toString(r[2]));
                }
                if(reg==11)
                {
                    r[3]=Integer.rotateRight(r[3],count);
                    R3Textfield.setText(Integer.toString(r[3]));
                }
            }
        }
        else    
        {
          TextArea2.append("\nNo rotation..");
        }
    }

    private void absfunc(int i) 
    {
        if(i==00)
        {
            if(r[0]<0)
                r[0]=-r[0];
        }
        if(i==01)
        {
            if(r[1]<0)
            r[1]=-r[1];
        }
        if(i==10)
        {
            if(r[2]<0)
            r[2]=-r[2];
        }
        if(i==11)
        {
            if(r[3]<0)
            r[3]=-r[3];
        }
     }

    
    public void loadregister1(int reg,int ea1){
        if(reg==00)
            r[0]=memory[ea1];
        if(reg==01)
            r[1]=memory[ea1];
        if(reg==10)
          r[2]=memory[ea1];
        if(reg==11)
           r[3]=memory[ea1];
    }
    
    public void storeregister1(int reg,int ea1){
        if(reg==00)
            memory[ea1]=r[0];
        if(reg==01)
            memory[ea1]=r[1];
        if(reg==10)
           memory[ea1]=r[2];
        if(reg==11)
           memory[ea1]=r[3];        
    }
    
    public void subtract1(int reg,int ea1){
        if(reg==00)
            r[0]=r[0]-memory[ea1];
        if(reg==01)
            r[1]=r[1]-memory[ea1];
        if(reg==10)
          r[2]=r[2]-memory[ea1];
        if(reg==11)
           r[3]=r[3]-memory[ea1];
            if(r[rr]==0)
            MSRTextField.setText("Z");
                    if(r[rr]<0)
            MSRTextField.setText("N");
    }

    private void prg2() {
   try{
        if(!TextArea.getText().equals(""))
    {
    BufferedReader buf=new BufferedReader(new InputStreamReader(new DataInputStream(new FileInputStream("C:/Users/prave/OneDrive/Documents/NetBeansProjects/Simulator/src/simulator/paragraph.txt"))));
    String sentence;
    int s = 0,i;
    String[] ar = null;
    String search=TextArea.getText();
    while((sentence=buf.readLine())!=null)
    {
        ar=sentence.split("\\.");            
    }
    for(i=0;i<ar.length;i++)
    {
        if(ar[i].indexOf(search)!=-1)
        {
            s=i+1;
            break;
        }
    }
    TextArea2.append("\n\nSearching for the entered word:");
    if(s==0)
        TextArea2.append("\nWord not found");
    else
    {
        TextArea2.append("\nFound at sentence "+s);
        String lineIwant=ar[s-1];
        TextArea2.append("\nWord number:"+(Arrays.asList(lineIwant.split("\\s+")).indexOf(search)+1));
    }
    }
    else
        TextArea2.append("Word to be searched for is not entered.");
}
   catch(IOException e)
   {
       
   }
 }
    
    
}

